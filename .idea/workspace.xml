<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="BranchesTreeState">
    <expand />
    <select>
      <path>
        <item name="ROOT" type="e8cecc67:BranchNodeDescriptor" />
        <item name="LOCAL_ROOT" type="e8cecc67:BranchNodeDescriptor" />
      </path>
    </select>
  </component>
  <component name="ChangeListManager">
    <list default="true" id="7dbb84ff-cb70-4f33-84ac-c2138746d980" name="Default Changelist" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DefaultGradleProjectSettings">
    <option name="isMigrated" value="true" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="JUnit5 Test Class" />
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
    <option name="PUSH_TAGS">
      <GitPushTagMode />
    </option>
  </component>
  <component name="GithubPullRequestsUISettings">
    <option name="hiddenUrls">
      <set>
        <option value="https://github.com/snehasishroy/leetcode-practice.git" />
      </set>
    </option>
  </component>
  <component name="MavenImportPreferences">
    <option name="importingSettings">
      <MavenImportingSettings>
        <option name="vmOptionsForImporter" value="-Xmx768m" />
      </MavenImportingSettings>
    </option>
  </component>
  <component name="ProjectId" id="1OYjUozR2wA5XfxN4lSupdXEdA9" />
  <component name="ProjectLevelVcsManager">
    <ConfirmationsSetting value="1" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="Downloaded.Files.Path.Enabled" value="false" />
    <property name="Repository.Attach.Annotations" value="true" />
    <property name="Repository.Attach.JavaDocs" value="true" />
    <property name="Repository.Attach.Sources" value="true" />
    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="ToolWindowRun.ShowToolbar" value="false" />
    <property name="com.intellij.ide.scratch.LRUPopupBuilder$1/New Scratch File" value="JAVA" />
    <property name="com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrary" value="JUnit5" />
    <property name="com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrarySuperClass.JUnit5" value="" />
    <property name="extract.method.default.visibility" value="private" />
    <property name="last.edited.regexp" value="abc\ntasd\n" />
    <property name="last_directory_selection" value="$PROJECT_DIR$/src/main/java/common" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="project.structure.last.edited" value="Modules" />
    <property name="project.structure.proportion" value="0.15" />
    <property name="project.structure.side.proportion" value="0.2" />
    <property name="restartRequiresConfirmation" value="false" />
    <property name="settings.editor.selected.configurable" value="com.codota.intellij.common.configuration.CodotaConfigurable" />
  </component>
  <component name="RecentsManager">
    <key name="CreateTestDialog.RecentsKey">
      <recent name="" />
    </key>
    <key name="MoveClassesOrPackagesDialog.RECENTS_KEY">
      <recent name="" />
      <recent name="alternate" />
      <recent name="common" />
    </key>
    <key name="MoveInnerDialog.RECENTS_KEY">
      <recent name="common" />
    </key>
    <key name="CopyClassDialog.RECENTS_KEY">
      <recent name="" />
    </key>
    <key name="CreateTestDialog.Recents.Supers">
      <recent name="" />
    </key>
  </component>
  <component name="RunManager" selected="Java Scratch.SegmentTree">
    <configuration name="LastStoneWeight2" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="LastStoneWeight2" />
      <module name="leetcode-practice" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="codeforces.Main" />
      <module name="leetcode-practice" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Unnamed" type="JUnit" factoryName="JUnit" nameIsGenerated="true">
      <module name="leetcode-practice" />
      <option name="MAIN_CLASS_NAME" value="" />
      <option name="METHOD_NAME" value="" />
      <option name="TEST_OBJECT" value="class" />
      <option name="PARAMETERS" value="" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Scratch (1)" type="Java Scratch" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="Scratch" />
      <option name="SCRATCH_FILE_URL" value="file://$APPLICATION_CONFIG_DIR$/scratches/scratch_1.java" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Scratch" type="Java Scratch" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="Scratch" />
      <option name="SCRATCH_FILE_URL" value="file://$APPLICATION_CONFIG_DIR$/scratches/scratch.java" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="SegmentTree" type="Java Scratch" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="SegmentTree" />
      <option name="SCRATCH_FILE_URL" value="file://$APPLICATION_CONFIG_DIR$/scratches/scratch_1.java" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <list>
      <item itemvalue="Application.LastStoneWeight2" />
      <item itemvalue="Application.Main" />
      <item itemvalue="Java Scratch.Scratch" />
      <item itemvalue="Java Scratch.Scratch (1)" />
      <item itemvalue="Java Scratch.SegmentTree" />
      <item itemvalue="JUnit.Unnamed" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Java Scratch.SegmentTree" />
        <item itemvalue="Java Scratch.Scratch (1)" />
        <item itemvalue="Application.Main" />
        <item itemvalue="Application.LastStoneWeight2" />
        <item itemvalue="Java Scratch.Scratch" />
      </list>
    </recent_temporary>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="project-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7dbb84ff-cb70-4f33-84ac-c2138746d980" name="Default Changelist" comment="" />
      <created>1561288929632</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1561288929632</updated>
    </task>
    <task id="LOCAL-00538" summary="Solve medium and tricky problem search in rotated sorted array when duplicates are present by removing the overlapping elements in second half &#10;&#10;[1,1,3,1] =&gt; [1,1,3] &#10;&#10;Perform binary search accordingly in first half or second half depending upon which partition the target element lies in">
      <created>1605886387152</created>
      <option name="number" value="00538" />
      <option name="presentableId" value="LOCAL-00538" />
      <option name="project" value="LOCAL" />
      <updated>1605886387152</updated>
    </task>
    <task id="LOCAL-00539" summary="Solve medium find a peak element in 1D array using errichto's binary search template.&#10;&#10;&#10;Finding a peak element in 2D array is trickier and uses divide and conquer algorithm">
      <created>1605894946875</created>
      <option name="number" value="00539" />
      <option name="presentableId" value="LOCAL-00539" />
      <option name="project" value="LOCAL" />
      <updated>1605894946875</updated>
    </task>
    <task id="LOCAL-00540" summary="Rewrite the code by considering each element's choice; either be added to the current set or be skipped. &#10;&#10;Instead of trying all elements in a loop. I feel this is logically more clear to visualize rather than the loop solution.">
      <created>1605896722766</created>
      <option name="number" value="00540" />
      <option name="presentableId" value="LOCAL-00540" />
      <option name="project" value="LOCAL" />
      <updated>1605896722766</updated>
    </task>
    <task id="LOCAL-00541" summary="Solve hard and tricky count unique characters of all substrings possible of a given string in first attempt !&#10;&#10;Leveraged prior learnings of identifying the contribution of each character and then repeating the process for all characters to get the final result. Trick is to understand that each character is bounded by it's previous and next occurrence in the string.">
      <created>1605906741331</created>
      <option name="number" value="00541" />
      <option name="presentableId" value="LOCAL-00541" />
      <option name="project" value="LOCAL" />
      <updated>1605906741331</updated>
    </task>
    <task id="LOCAL-00542" summary="Solve medium and extremely tricky to deduce the crux of the problem -- find the min stone possible after smashing all the stones&#10;&#10;Learnings -- Initially I went with greedy which was against all judgement because the max input range was [1,30] hinting at exponential complexity based solution but my greedy was nlogn&#10;&#10;Problem reduces to finding the min diff between two subsets in an array">
      <created>1605987631521</created>
      <option name="number" value="00542" />
      <option name="presentableId" value="LOCAL-00542" />
      <option name="project" value="LOCAL" />
      <updated>1605987631521</updated>
    </task>
    <task id="LOCAL-00543" summary="Solve medium print a linkedlist in reverse using sqrt(n) extra space by working on blocks of size sqrt. Create blocks containing sqrt(num) elements and reverse each block at a time.&#10;&#10;Learnings -- Introduction to sqrt decomposition in the most trivial question. Life works in mysterious ways.">
      <created>1606037667509</created>
      <option name="number" value="00543" />
      <option name="presentableId" value="LOCAL-00543" />
      <option name="project" value="LOCAL" />
      <updated>1606037667509</updated>
    </task>
    <task id="LOCAL-00544" summary="Solve medium count submatrices with all ones using 2D &quot;compression&quot; technique. Reduce the 2D problem to 1D. If there are n consecutive non zero element, no of subarrays would be n*(n+1)/2.&#10;&#10;Can be optimized to n^2 using monotonic stack but I don't fully understand this solution at the moment.">
      <created>1606055259100</created>
      <option name="number" value="00544" />
      <option name="presentableId" value="LOCAL-00544" />
      <option name="project" value="LOCAL" />
      <updated>1606055259100</updated>
    </task>
    <task id="LOCAL-00545" summary="Solve easy find the total weight of nested list by performing DFS and keeping track of current depth.">
      <created>1606059156121</created>
      <option name="number" value="00545" />
      <option name="presentableId" value="LOCAL-00545" />
      <option name="project" value="LOCAL" />
      <updated>1606059156121</updated>
    </task>
    <task id="LOCAL-00546" summary="Solve hard find the new max size of island after converting a 0 to 1 by using union find&#10;&#10;Learnings -- Was able to write union find code on my own by leveraging previous learnings. Thanks to the wonderful intro to Union Find in GraphValidTree">
      <created>1606063863171</created>
      <option name="number" value="00546" />
      <option name="presentableId" value="LOCAL-00546" />
      <option name="project" value="LOCAL" />
      <updated>1606063863171</updated>
    </task>
    <task id="LOCAL-00547" summary="Solve medium and tricky find the min distance between two sets of islands using multi source bfs&#10;&#10;Learnings -- I could not initially think about the multi source bfs, &#10;&#10;Initially, I went ahead with normal bfs + keeping track of min distance. Then I got WA when a cell is reachable from multiple cells of first island. Then I thought instead of visited cell, I would need BFS with pruning i.e proceed ahead if I can reach a cell with min distance. Which got me AC at ~22ms&#10;&#10;Then I thought of multi source bfs by checking the implementation of RottingOranges, and it got me AC at ~9 ms&#10;&#10;Bidirectional BFS can reduce the runtime even lower">
      <created>1606133931408</created>
      <option name="number" value="00547" />
      <option name="presentableId" value="LOCAL-00547" />
      <option name="project" value="LOCAL" />
      <updated>1606133931408</updated>
    </task>
    <task id="LOCAL-00548" summary="Solve hard find a number in mountain array using 3 binary searches, first find the peak element and then apply binary search in either of the partitions.&#10;&#10;Learnings -- For finding a number in modified sorted array always find the pivot element first. Then apply binary search in the partitions to find the target number.">
      <created>1606142593079</created>
      <option name="number" value="00548" />
      <option name="presentableId" value="LOCAL-00548" />
      <option name="project" value="LOCAL" />
      <updated>1606142593079</updated>
    </task>
    <task id="LOCAL-00549" summary="Solve hard and tricky find the median of a sliding window using two treeMap's &#10;&#10;Learnings -- 1. TreeMap can be used in place of priority queue in situations where removal is required as treeMap supports logn for removal&#10;2. firstKey() returns the first key of map, so in case of normal treeMap it returns the smallest key else in case of descending treeMap, it returns the largest key&#10;3. Take care while counting the elements in treeMap when used as priority queue because a no can occur more than 1.">
      <created>1606159637274</created>
      <option name="number" value="00549" />
      <option name="presentableId" value="LOCAL-00549" />
      <option name="project" value="LOCAL" />
      <updated>1606159637275</updated>
    </task>
    <task id="LOCAL-00550" summary="Add clarifications in the logic behind setting the bounds in recursion. Do note that the parent bounds must be obeyed">
      <created>1606222649518</created>
      <option name="number" value="00550" />
      <option name="presentableId" value="LOCAL-00550" />
      <option name="project" value="LOCAL" />
      <updated>1606222649518</updated>
    </task>
    <task id="LOCAL-00551" summary="Solve medium and tricky math problem find length of smallest integer with repeated 1's i.e 1, 11, 111, 1111, 11111, 111111.. that divides k&#10;&#10;We are required to return only the length as the actual no can be very huge. Since we can't store the number itself, we have to rely on current remainder to generate the remainder of the next no in series. That was a pretty cool math trick.&#10;&#10;Another trick is to realize that we can have only a finite set of remainders so sometimes remainders can repeat. When they do, we got ourselves an infinite loop. We have to use a set to keep track of seen remainders.">
      <created>1606312065267</created>
      <option name="number" value="00551" />
      <option name="presentableId" value="LOCAL-00551" />
      <option name="project" value="LOCAL" />
      <updated>1606312065267</updated>
    </task>
    <task id="LOCAL-00552" summary="Solve hard and tricky nested string problem -- evaluate nested expression containing + and - i.e. 2-(3+5) using stack of stack&#10;&#10;Leveraged prior learnings of solving nested questions like NumberOfAtoms, DecodeString. First identify what is required to solve a single expression, then try to create stack of whatever was required. &#10;&#10;Gotchas: Take care of prefix/suffix of nested expression. Don't forget to freaking reset the variables upon start/end of expression.">
      <created>1606324615049</created>
      <option name="number" value="00552" />
      <option name="presentableId" value="LOCAL-00552" />
      <option name="project" value="LOCAL" />
      <updated>1606324615049</updated>
    </task>
    <task id="LOCAL-00553" summary="Solve medium and tricky evaluate an expression containing + - / % using stack&#10;&#10;Initially I implemented it with 2 stacks but that's an overkill if we look closely. We always have to evaluate * and / first because they are the highest rank operators.&#10;&#10;Also for handling -, assign - to the operand instead of the operator to handle 0's">
      <created>1606328688491</created>
      <option name="number" value="00553" />
      <option name="presentableId" value="LOCAL-00553" />
      <option name="project" value="LOCAL" />
      <updated>1606328688491</updated>
    </task>
    <task id="LOCAL-00554" summary="Solve hard find running median from data stream using 2 Priority queues&#10;&#10;Leveraged prior learnings of solving SlidingWindowMedian">
      <created>1606332513861</created>
      <option name="number" value="00554" />
      <option name="presentableId" value="LOCAL-00554" />
      <option name="project" value="LOCAL" />
      <updated>1606332513861</updated>
    </task>
    <task id="LOCAL-00555" summary="Solve medium and a bit tricky find all duplicate subtrees in a tree by creating hashes of subtrees as we iterate the tree using preorder traversal.&#10;&#10;Took me some time but was able to write it on my own. Leveraged prior learnings of Serialize&amp;DeserializeBinaryTree by representing the tree using preorder traversal.">
      <created>1606583352615</created>
      <option name="number" value="00555" />
      <option name="presentableId" value="LOCAL-00555" />
      <option name="project" value="LOCAL" />
      <updated>1606583352615</updated>
    </task>
    <task id="LOCAL-00556" summary="Solve medium and a bit tricky find whether the current set of dislikes relationships are bipartite by trying to assign the opposite color to the neighbour. In my initial implementation I wrote a recursive backtracking code, it was pretty unique TBH :D&#10;&#10;Learnings -- 1. Model the relationship as fucking graph&#10;2. If two nodes can't be &quot;together&quot;, this means they can't be connected. Solve this by trying to assign opposite colors to the neighbour.">
      <created>1606584924893</created>
      <option name="number" value="00556" />
      <option name="presentableId" value="LOCAL-00556" />
      <option name="project" value="LOCAL" />
      <updated>1606584924893</updated>
    </task>
    <task id="LOCAL-00557" summary="Solve medium problem whose indirect ask was to find the max distance of each node from the leaf and return it sorted by distance.&#10;&#10;In my initial solution I did a 2 pass code, first pass for finding the height of the tree and second pass to add the node to correct bucket but those can be combined in one pass by comparing the size of the current result and the current bucket">
      <created>1606587310268</created>
      <option name="number" value="00557" />
      <option name="presentableId" value="LOCAL-00557" />
      <option name="project" value="LOCAL" />
      <updated>1606587310268</updated>
    </task>
    <task id="LOCAL-00558" summary="Solve medium and tricky problem, find whether a ball can stop at the target cell, the ball once moved in a certain direction can only change direction if it can't move ahead in the current direction.&#10;&#10;This is a similar problem to RobotRoomCleaner but differs in the part when the ball can change direction. Initially I implemented it all wrong and changed direction at each cell. The simpler thing to do would be to find the last cell in which the ball stops in the current direction and do DFS recursively in the next 4 directions.">
      <created>1606659873975</created>
      <option name="number" value="00558" />
      <option name="presentableId" value="LOCAL-00558" />
      <option name="project" value="LOCAL" />
      <updated>1606659873975</updated>
    </task>
    <task id="LOCAL-00559" summary="Solve medium and followup to the previous problem, find the shortest distance between source and target cells, given the ball can change direction only if its stopped.&#10;&#10;Since the task is to find shortest length and the edge weights are variable, need to either use bfs with pruning where we traverse the entire graph or use djikstra that returns the shortest path to reach a given cell.">
      <created>1606664088585</created>
      <option name="number" value="00559" />
      <option name="presentableId" value="LOCAL-00559" />
      <option name="project" value="LOCAL" />
      <updated>1606664088585</updated>
    </task>
    <task id="LOCAL-00560" summary="Solve medium find whether two expression trees are equivalent expressions, if they have only + as an operator by verifying whether they contain the same operands or not.&#10;&#10;Feeling frustrated as I went down the wrong path by checking whether the trees are flip equivalent or not">
      <created>1606676136174</created>
      <option name="number" value="00560" />
      <option name="presentableId" value="LOCAL-00560" />
      <option name="project" value="LOCAL" />
      <updated>1606676136175</updated>
    </task>
    <task id="LOCAL-00561" summary="Solve medium and extremely tricky problem find whether an array can be split into subsequences containing consecutive numbers by greedy algo&#10;&#10;Learnings -- Greedy algos show no pattern man ! Damn ! Each greedy algo is kinda unique ! Here the trick is to check whether the current no can be used to extend some existing subsequence or it should start its own subsequence.">
      <created>1606687812426</created>
      <option name="number" value="00561" />
      <option name="presentableId" value="LOCAL-00561" />
      <option name="project" value="LOCAL" />
      <updated>1606687812426</updated>
    </task>
    <task id="LOCAL-00562" summary="Solve medium and tricky problem, find the kth missing element in sorted array using binary search and linear search by finding count of elements missing till a specific index.&#10;&#10;I should have at least solved the problem using linear search, feeling a bit disappointed.">
      <created>1606755241271</created>
      <option name="number" value="00562" />
      <option name="presentableId" value="LOCAL-00562" />
      <option name="project" value="LOCAL" />
      <updated>1606755241272</updated>
    </task>
    <task id="LOCAL-00563" summary="Solve medium and tricky problem, find the maximum of minimum distance between two balls given that we have to place m balls using binary search.&#10;&#10;Leveraged prior learnings of solving DivideChocolates to code up the binary search solution. Possible pattern is to use binary search when the output can be 1,2,3.... n and verifying whether a certain value satisfy the constraint takes linear or constant time, we can use binary search">
      <created>1606771037310</created>
      <option name="number" value="00563" />
      <option name="presentableId" value="LOCAL-00563" />
      <option name="project" value="LOCAL" />
      <updated>1606771037310</updated>
    </task>
    <task id="LOCAL-00564" summary="Solve medium and tricky problem, find the minimum speed to eat all the bananas in &lt;= h hours using binary search&#10;&#10;Learnings -- If the output can be either 1,2,3...n and verifying whether the target satisfies the input constraint takes linear time, we can apply binary search.">
      <created>1606838585386</created>
      <option name="number" value="00564" />
      <option name="presentableId" value="LOCAL-00564" />
      <option name="project" value="LOCAL" />
      <updated>1606838585386</updated>
    </task>
    <task id="LOCAL-00565" summary="Add gotcha in finding the min subarray that needs to be removed to make the remaining subarray sum divisible by p">
      <created>1606858613370</created>
      <option name="number" value="00565" />
      <option name="presentableId" value="LOCAL-00565" />
      <option name="project" value="LOCAL" />
      <updated>1606858613370</updated>
    </task>
    <task id="LOCAL-00566" summary="Solve hard and tricky find the longest repeated substring in string using binary search + rolling hash&#10;&#10;Binary search was not that difficult to identify but rolling hash took a lot of time due to modulo arithmetic in handling negative hashes. Also care must be taken to properly calculate new hash. Take care of indices and the multiplication factor.&#10;&#10;LCS can also be used to find the answer but it would have been n^2 and would have timed out due to higher input bound">
      <created>1606859023097</created>
      <option name="number" value="00566" />
      <option name="presentableId" value="LOCAL-00566" />
      <option name="project" value="LOCAL" />
      <updated>1606859023097</updated>
    </task>
    <task id="LOCAL-00567" summary="Solve medium find longest subarray that sums to a target value using prefix sum + hashmap&#10;&#10;Leveraged prior learnings of using prefix sum to deal with subarray sum problems. Only trick here was not updating the prefixsum in case an index with same prefix sum already exists -- this will help in finding the longest subarray">
      <created>1606861369842</created>
      <option name="number" value="00567" />
      <option name="presentableId" value="LOCAL-00567" />
      <option name="project" value="LOCAL" />
      <updated>1606861369842</updated>
    </task>
    <task id="LOCAL-00568" summary="Solve medium pick a random node from an infinitely long list using reservoir sampling. Fix the first kth element in the reservoir, then for the next element, put it in the reservoir only if the randomIndex is &lt; k. RandomIndex is [0, currentIndex)">
      <created>1606920086508</created>
      <option name="number" value="00568" />
      <option name="presentableId" value="LOCAL-00568" />
      <option name="project" value="LOCAL" />
      <updated>1606920086508</updated>
    </task>
    <task id="LOCAL-00569" summary="Solve medium design search suggestion system where given a search word, list all the products that start with each prefix of the search word using trie&#10;&#10;Leveraged prior learnings of storing useful information directly in trie node to avoid DFS">
      <created>1606925195595</created>
      <option name="number" value="00569" />
      <option name="presentableId" value="LOCAL-00569" />
      <option name="project" value="LOCAL" />
      <updated>1606925195595</updated>
    </task>
    <task id="LOCAL-00570" summary="Solve medium and a bit tricky find the longest chain of words that extend previous word by adding one character anywhere in previous word by either looking for next words in chain or previous words in chain.&#10;&#10;Looking for next words takes time because we have to generate all combinations to see whether such word exists or not, Looking for previous words is much faster">
      <created>1607008230899</created>
      <option name="number" value="00570" />
      <option name="presentableId" value="LOCAL-00570" />
      <option name="project" value="LOCAL" />
      <updated>1607008230900</updated>
    </task>
    <task id="LOCAL-00571" summary="Solve medium and a bit tricky find the shortest path of moving from one letter to another provided a string and a board of letters.&#10;&#10;Initially I thought of using BFS from prev letter to current letter, but then thought that comparing previous location with current location would suffice. Only thing that caused trouble was Z as from Z we have to move up first, then right.&#10;If we have to reach Z, we have to move left first, then down.">
      <created>1607009894579</created>
      <option name="number" value="00571" />
      <option name="presentableId" value="LOCAL-00571" />
      <option name="project" value="LOCAL" />
      <updated>1607009894579</updated>
    </task>
    <task id="LOCAL-00572" summary="Solve medium and math related divisibility problem, find count of pairs of numbers that are divisible by 60 by finding pairs of numbers whose mod sum = 60, This is similar to 2Sum Problem where we have to find two numbers such that a + b = k&#10;&#10;Take care of duplicates. Either use binary search or hashmap to count pairs.">
      <created>1607011464342</created>
      <option name="number" value="00572" />
      <option name="presentableId" value="LOCAL-00572" />
      <option name="project" value="LOCAL" />
      <updated>1607011464342</updated>
    </task>
    <task id="LOCAL-00573" summary="Solve medium and math related tricky 2D matrix problem, find the sum of all elements from (r1, c1) till (r2, c2) using 2D prefix sum&#10;&#10;Really happy to solve this question in first attempt, took me some time to visualize the prefix sum logic and conditions. Verified it manually on paper, only after that started coding. Woooohooo.">
      <created>1607014680713</created>
      <option name="number" value="00573" />
      <option name="presentableId" value="LOCAL-00573" />
      <option name="project" value="LOCAL" />
      <updated>1607014680713</updated>
    </task>
    <task id="LOCAL-00574" summary="Solve medium and tricky graph theory problem, find a way to visit each edge exactly once such the path is lexicographically smallest by greedy backtracking and using hierholzer algorithm to find the eulerian path of the graph&#10;&#10;Learnings -- Visiting each edge exactly once is well known graph theory problem known as eulerian path/cycle. It can be found by doing a postorder traversal of the graph, similar to the way we perform topological sorting using stack.&#10;&#10;Make sure to account for parallel edges/duplicate edges in graph problems unless specified. If there is duplicate edges, solve them by creating a key for each edge (src-&gt;target) and tracking their count. Decrement the count, when we visit a edge.">
      <created>1607112348672</created>
      <option name="number" value="00574" />
      <option name="presentableId" value="LOCAL-00574" />
      <option name="project" value="LOCAL" />
      <updated>1607112348672</updated>
    </task>
    <task id="LOCAL-00575" summary="Solve hard and extremely tricky divide and conquer problem, find the max profit after bursting balloons. Was asked this question in Zeta onsite back in 2019. &#10;&#10;Atleast this time I was able to solve using backtracking :P&#10;&#10;Learnings -- Divide and conquer and greedy are tough sons of bitches.">
      <created>1607172855612</created>
      <option name="number" value="00575" />
      <option name="presentableId" value="LOCAL-00575" />
      <option name="project" value="LOCAL" />
      <updated>1607172855612</updated>
    </task>
    <task id="LOCAL-00576" summary="Solve medium find the longest arithmetic subsequence in an array using the same concept as LIS. Was able to think about the n^2 solution instantaneously :P Sometimes I feel like a genius">
      <created>1607173223412</created>
      <option name="number" value="00576" />
      <option name="presentableId" value="LOCAL-00576" />
      <option name="project" value="LOCAL" />
      <updated>1607173223412</updated>
    </task>
    <task id="LOCAL-00577" summary="Solve medium and a bit tricky problem, find the total probability of knight remaining on the chessboard after making k moves. &#10;&#10;I am a bit surprised to do this in first attempt. Think I am getting a little good :P &#10;&#10;A gotcha to make the solution memoizable is to return results of each subproblem independently of another. Initially I was thinking of passing in the current prob as a prefix multiplier but then discarded it">
      <created>1607176110831</created>
      <option name="number" value="00577" />
      <option name="presentableId" value="LOCAL-00577" />
      <option name="project" value="LOCAL" />
      <updated>1607176110832</updated>
    </task>
    <task id="LOCAL-00578" summary="Add clarification on why visited array isn't required in problems with max steps/length permissible">
      <created>1607181527763</created>
      <option name="number" value="00578" />
      <option name="presentableId" value="LOCAL-00578" />
      <option name="project" value="LOCAL" />
      <updated>1607181527763</updated>
    </task>
    <task id="LOCAL-00579" summary="Solve medium find the total no of ways of reaching outside the grid given we can only traverse finite number of steps using DFS + Memoization.&#10;&#10;Leveraged prior learnings of solving problems related to finding total no of ways of doing something by returning 1 only at the end state and keeping track of total no of ways at each step.">
      <created>1607182032394</created>
      <option name="number" value="00579" />
      <option name="presentableId" value="LOCAL-00579" />
      <option name="project" value="LOCAL" />
      <updated>1607182032394</updated>
    </task>
    <task id="LOCAL-00580" summary="Add a bit of clarification regarding greedy way of generating euler path over backtracking approach">
      <created>1607196989700</created>
      <option name="number" value="00580" />
      <option name="presentableId" value="LOCAL-00580" />
      <option name="project" value="LOCAL" />
      <updated>1607196989700</updated>
    </task>
    <task id="LOCAL-00581" summary="Solve hard and extremely trick problem, find the shortest string that contains all permutation of n digits of numbers containing k digits by modelling it as a fucking graph and doing backtracking to generate euler path that visits all edges exactly once.&#10;&#10;I could not think of modelling it as a graph during the thought process, I started to solve it using Trie as it involves prefixes.">
      <created>1607197150070</created>
      <option name="number" value="00581" />
      <option name="presentableId" value="LOCAL-00581" />
      <option name="project" value="LOCAL" />
      <updated>1607197150070</updated>
    </task>
    <task id="LOCAL-00582" summary="Fix grammatical mistake">
      <created>1607270051315</created>
      <option name="number" value="00582" />
      <option name="presentableId" value="LOCAL-00582" />
      <option name="project" value="LOCAL" />
      <updated>1607270051315</updated>
    </task>
    <task id="LOCAL-00583" summary="Add clarification around why changing the problem statement to &quot;non-decreasing&quot; can introduce cycles in the graph, possibly increasing the time complexity">
      <created>1607288914813</created>
      <option name="number" value="00583" />
      <option name="presentableId" value="LOCAL-00583" />
      <option name="project" value="LOCAL" />
      <updated>1607288914813</updated>
    </task>
    <task id="LOCAL-00584" summary="Solve medium and extremely tricky problem, find the path with maximum minimum value possible from source to target in a grid using &#10; 3 approaches: binary search or priority queue or union find&#10; &#10;Learnings -- In case of grid problems where traversal in 4 direction is permissible make sure to handle cycles. If you are memoizing the solution, make sure the memoized value does not depend upon the initial path that was taken to visit that cell. &#10;&#10;Binary search is to go to approach for dealing with maximum minimum problems">
      <created>1607289096122</created>
      <option name="number" value="00584" />
      <option name="presentableId" value="LOCAL-00584" />
      <option name="project" value="LOCAL" />
      <updated>1607289096122</updated>
    </task>
    <task id="LOCAL-00585" summary="Solve medium and extremely tricky problem, find the path with minimum effort. Effort here is the max diff between two adjacent elements. Multiple ways of solving this problem, Djikstra, Binary Search or Union Find.">
      <created>1607360079377</created>
      <option name="number" value="00585" />
      <option name="presentableId" value="LOCAL-00585" />
      <option name="project" value="LOCAL" />
      <updated>1607360079377</updated>
    </task>
    <task id="LOCAL-00586" summary="Solve medium and extremely tricky problem, find the lexicographically smallest string that is possible by swapping pairs of provided indices any number of times by reducing the problem to connected components. Characters in every component can be sorted individually to get the result.&#10;&#10;I tried solving using greedy but couldn't make it work.">
      <created>1607365896921</created>
      <option name="number" value="00586" />
      <option name="presentableId" value="LOCAL-00586" />
      <option name="project" value="LOCAL" />
      <updated>1607365896921</updated>
    </task>
    <option name="localTasksCounter" value="587" />
    <servers />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="1">
          <value>
            <State>
              <option name="FILTERS">
                <map>
                  <entry key="roots">
                    <value>
                      <list>
                        <option value="$PROJECT_DIR$" />
                      </list>
                    </value>
                  </entry>
                </map>
              </option>
            </State>
          </value>
        </entry>
        <entry key="2">
          <value>
            <State>
              <option name="FILTERS">
                <map>
                  <entry key="roots">
                    <value>
                      <list>
                        <option value="$PROJECT_DIR$" />
                      </list>
                    </value>
                  </entry>
                  <entry key="text">
                    <value>
                      <list>
                        <option value="hard and tricky" />
                      </list>
                    </value>
                  </entry>
                  <entry key="user">
                    <value>
                      <list>
                        <option value="snehasishiiita" />
                      </list>
                    </value>
                  </entry>
                </map>
              </option>
            </State>
          </value>
        </entry>
        <entry key="MAIN">
          <value>
            <State />
          </value>
        </entry>
      </map>
    </option>
    <option name="oldMeFiltersMigrated" value="true" />
  </component>
  <component name="VcsManagerConfiguration">
    <option name="CHECK_CODE_CLEANUP_BEFORE_PROJECT_COMMIT" value="true" />
    <MESSAGE value="Solve medium and tricky problem, find the kth missing element in sorted array using binary search and linear search by finding count of elements missing till a specific index.&#10;&#10;I should have at least solved the problem using linear search, feeling a bit disappointed." />
    <MESSAGE value="Solve medium and tricky problem, find the maximum of minimum distance between two balls given that we have to place m balls using binary search.&#10;&#10;Leveraged prior learnings of solving DivideChocolates to code up the binary search solution. Possible pattern is to use binary search when the output can be 1,2,3.... n and verifying whether a certain value satisfy the constraint takes linear or constant time, we can use binary search" />
    <MESSAGE value="Solve medium and tricky problem, find the minimum speed to eat all the bananas in &lt;= h hours using binary search&#10;&#10;Learnings -- If the output can be either 1,2,3...n and verifying whether the target satisfies the input constraint takes linear time, we can apply binary search." />
    <MESSAGE value="Add gotcha in finding the min subarray that needs to be removed to make the remaining subarray sum divisible by p" />
    <MESSAGE value="Solve hard and tricky find the longest repeated substring in string using binary search + rolling hash&#10;&#10;Binary search was not that difficult to identify but rolling hash took a lot of time due to modulo arithmetic in handling negative hashes. Also care must be taken to properly calculate new hash. Take care of indices and the multiplication factor.&#10;&#10;LCS can also be used to find the answer but it would have been n^2 and would have timed out due to higher input bound" />
    <MESSAGE value="Solve medium find longest subarray that sums to a target value using prefix sum + hashmap&#10;&#10;Leveraged prior learnings of using prefix sum to deal with subarray sum problems. Only trick here was not updating the prefixsum in case an index with same prefix sum already exists -- this will help in finding the longest subarray" />
    <MESSAGE value="Solve medium pick a random node from an infinitely long list using reservoir sampling. Fix the first kth element in the reservoir, then for the next element, put it in the reservoir only if the randomIndex is &lt; k. RandomIndex is [0, currentIndex)" />
    <MESSAGE value="Solve medium design search suggestion system where given a search word, list all the products that start with each prefix of the search word using trie&#10;&#10;Leveraged prior learnings of storing useful information directly in trie node to avoid DFS" />
    <MESSAGE value="Solve medium and a bit tricky find the longest chain of words that extend previous word by adding one character anywhere in previous word by either looking for next words in chain or previous words in chain.&#10;&#10;Looking for next words takes time because we have to generate all combinations to see whether such word exists or not, Looking for previous words is much faster" />
    <MESSAGE value="Solve medium and a bit tricky find the shortest path of moving from one letter to another provided a string and a board of letters.&#10;&#10;Initially I thought of using BFS from prev letter to current letter, but then thought that comparing previous location with current location would suffice. Only thing that caused trouble was Z as from Z we have to move up first, then right.&#10;If we have to reach Z, we have to move left first, then down." />
    <MESSAGE value="Solve medium and math related divisibility problem, find count of pairs of numbers that are divisible by 60 by finding pairs of numbers whose mod sum = 60, This is similar to 2Sum Problem where we have to find two numbers such that a + b = k&#10;&#10;Take care of duplicates. Either use binary search or hashmap to count pairs." />
    <MESSAGE value="Solve medium and math related tricky 2D matrix problem, find the sum of all elements from (r1, c1) till (r2, c2) using 2D prefix sum&#10;&#10;Really happy to solve this question in first attempt, took me some time to visualize the prefix sum logic and conditions. Verified it manually on paper, only after that started coding. Woooohooo." />
    <MESSAGE value="Solve medium and tricky graph theory problem, find a way to visit each edge exactly once such the path is lexicographically smallest by greedy backtracking and using hierholzer algorithm to find the eulerian path of the graph&#10;&#10;Learnings -- Visiting each edge exactly once is well known graph theory problem known as eulerian path/cycle. It can be found by doing a postorder traversal of the graph, similar to the way we perform topological sorting using stack.&#10;&#10;Make sure to account for parallel edges/duplicate edges in graph problems unless specified. If there is duplicate edges, solve them by creating a key for each edge (src-&gt;target) and tracking their count. Decrement the count, when we visit a edge." />
    <MESSAGE value="Solve hard and extremely tricky divide and conquer problem, find the max profit after bursting balloons. Was asked this question in Zeta onsite back in 2019. &#10;&#10;Atleast this time I was able to solve using backtracking :P&#10;&#10;Learnings -- Divide and conquer and greedy are tough sons of bitches." />
    <MESSAGE value="Solve medium find the longest arithmetic subsequence in an array using the same concept as LIS. Was able to think about the n^2 solution instantaneously :P Sometimes I feel like a genius" />
    <MESSAGE value="Solve medium and a bit tricky problem, find the total probability of knight remaining on the chessboard after making k moves. &#10;&#10;I am a bit surprised to do this in first attempt. Think I am getting a little good :P &#10;&#10;A gotcha to make the solution memoizable is to return results of each subproblem independently of another. Initially I was thinking of passing in the current prob as a prefix multiplier but then discarded it" />
    <MESSAGE value="Add clarification on why visited array isn't required in problems with max steps/length permissible" />
    <MESSAGE value="Solve medium find the total no of ways of reaching outside the grid given we can only traverse finite number of steps using DFS + Memoization.&#10;&#10;Leveraged prior learnings of solving problems related to finding total no of ways of doing something by returning 1 only at the end state and keeping track of total no of ways at each step." />
    <MESSAGE value="Add a bit of clarification regarding greedy way of generating euler path over backtracking approach" />
    <MESSAGE value="Solve hard and extremely trick problem, find the shortest string that contains all permutation of n digits of numbers containing k digits by modelling it as a fucking graph and doing backtracking to generate euler path that visits all edges exactly once.&#10;&#10;I could not think of modelling it as a graph during the thought process, I started to solve it using Trie as it involves prefixes." />
    <MESSAGE value="Fix grammatical mistake" />
    <MESSAGE value="Add clarification around why changing the problem statement to &quot;non-decreasing&quot; can introduce cycles in the graph, possibly increasing the time complexity" />
    <MESSAGE value="Solve medium and extremely tricky problem, find the path with maximum minimum value possible from source to target in a grid using &#10; 3 approaches: binary search or priority queue or union find&#10; &#10;Learnings -- In case of grid problems where traversal in 4 direction is permissible make sure to handle cycles. If you are memoizing the solution, make sure the memoized value does not depend upon the initial path that was taken to visit that cell. &#10;&#10;Binary search is to go to approach for dealing with maximum minimum problems" />
    <MESSAGE value="Solve medium and extremely tricky problem, find the path with minimum effort. Effort here is the max diff between two adjacent elements. Multiple ways of solving this problem, Djikstra, Binary Search or Union Find." />
    <MESSAGE value="Solve medium and extremely tricky problem, find the lexicographically smallest string that is possible by swapping pairs of provided indices any number of times by reducing the problem to connected components. Characters in every component can be sorted individually to get the result.&#10;&#10;I tried solving using greedy but couldn't make it work." />
    <option name="LAST_COMMIT_MESSAGE" value="Solve medium and extremely tricky problem, find the lexicographically smallest string that is possible by swapping pairs of provided indices any number of times by reducing the problem to connected components. Characters in every component can be sorted individually to get the result.&#10;&#10;I tried solving using greedy but couldn't make it work." />
    <option name="OPTIMIZE_IMPORTS_BEFORE_PROJECT_COMMIT" value="true" />
    <option name="REFORMAT_BEFORE_PROJECT_COMMIT" value="true" />
    <option name="REARRANGE_BEFORE_PROJECT_COMMIT" value="true" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/DistinctSubsequences.java</url>
          <line>78</line>
          <option name="timeStamp" value="1" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/SortColors.java</url>
          <line>29</line>
          <option name="timeStamp" value="2" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/GeneralizedAbbreviations.java</url>
          <line>33</line>
          <option name="timeStamp" value="8" />
        </line-breakpoint>
      </breakpoints>
      <default-breakpoints>
        <breakpoint enabled="true" type="java-exception">
          <condition expression="this instanceof StringIndexOutOfBoundsException" language="JAVA" />
          <properties>
            <catch-class-filters>
              <class-filter pattern="java.lang.ArrayIndexOutOfBoundsException" />
            </catch-class-filters>
          </properties>
        </breakpoint>
      </default-breakpoints>
    </breakpoint-manager>
    <watches-manager>
      <configuration name="JUnit">
        <watch expression="grid" />
        <watch expression="uniqueString.entrySet().toArray()[0]" />
      </configuration>
    </watches-manager>
  </component>
  <component name="XSLT-Support.FileAssociations.UIState">
    <expand />
    <select />
  </component>
</project>