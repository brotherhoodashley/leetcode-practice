<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="BranchesTreeState">
    <expand />
    <select>
      <path>
        <item name="ROOT" type="e8cecc67:BranchNodeDescriptor" />
        <item name="LOCAL_ROOT" type="e8cecc67:BranchNodeDescriptor" />
      </path>
    </select>
  </component>
  <component name="ChangeListManager">
    <list default="true" id="7dbb84ff-cb70-4f33-84ac-c2138746d980" name="Default Changelist" comment="Solve medium and tricky find the sum of absolute differences">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/main/java/DivideChocolates.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/DivideChocolates.java" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DefaultGradleProjectSettings">
    <option name="isMigrated" value="true" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="JUnit5 Test Class" />
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
    <option name="PUSH_TAGS">
      <GitPushTagMode />
    </option>
  </component>
  <component name="GithubPullRequestsUISettings">
    <option name="hiddenUrls">
      <set>
        <option value="https://github.com/snehasishroy/leetcode-practice.git" />
      </set>
    </option>
  </component>
  <component name="MavenImportPreferences">
    <option name="importingSettings">
      <MavenImportingSettings>
        <option name="vmOptionsForImporter" value="-Xmx768m" />
      </MavenImportingSettings>
    </option>
  </component>
  <component name="ProjectId" id="1OYjUozR2wA5XfxN4lSupdXEdA9" />
  <component name="ProjectLevelVcsManager">
    <ConfirmationsSetting value="1" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="Downloaded.Files.Path.Enabled" value="false" />
    <property name="Repository.Attach.Annotations" value="true" />
    <property name="Repository.Attach.JavaDocs" value="true" />
    <property name="Repository.Attach.Sources" value="true" />
    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="ToolWindowRun.ShowToolbar" value="false" />
    <property name="com.intellij.ide.scratch.LRUPopupBuilder$1/New Scratch File" value="JAVA" />
    <property name="com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrary" value="JUnit5" />
    <property name="com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrarySuperClass.JUnit5" value="" />
    <property name="extract.method.default.visibility" value="private" />
    <property name="last.edited.regexp" value="abc\ntasd\n" />
    <property name="last_directory_selection" value="$PROJECT_DIR$/src/main/java/common" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="project.structure.last.edited" value="Modules" />
    <property name="project.structure.proportion" value="0.15" />
    <property name="project.structure.side.proportion" value="0.2" />
    <property name="restartRequiresConfirmation" value="false" />
    <property name="settings.editor.selected.configurable" value="com.codota.intellij.common.configuration.CodotaConfigurable" />
  </component>
  <component name="RecentsManager">
    <key name="CreateTestDialog.RecentsKey">
      <recent name="" />
    </key>
    <key name="MoveClassesOrPackagesDialog.RECENTS_KEY">
      <recent name="" />
      <recent name="alternate" />
      <recent name="common" />
    </key>
    <key name="MoveInnerDialog.RECENTS_KEY">
      <recent name="common" />
    </key>
    <key name="CopyClassDialog.RECENTS_KEY">
      <recent name="" />
    </key>
    <key name="CreateTestDialog.Recents.Supers">
      <recent name="" />
    </key>
  </component>
  <component name="RunManager" selected="Java Scratch.Scratch">
    <configuration name="DivideChocolates" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="DivideChocolates" />
      <module name="leetcode-practice" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="codeforces.Main" />
      <module name="leetcode-practice" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Unnamed" type="JUnit" factoryName="JUnit" nameIsGenerated="true">
      <module name="leetcode-practice" />
      <option name="MAIN_CLASS_NAME" value="" />
      <option name="METHOD_NAME" value="" />
      <option name="TEST_OBJECT" value="class" />
      <option name="PARAMETERS" value="" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Scratch (1)" type="Java Scratch" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="Scratch" />
      <option name="SCRATCH_FILE_URL" value="file://$APPLICATION_CONFIG_DIR$/scratches/scratch_1.java" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Scratch" type="Java Scratch" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="Scratch" />
      <option name="SCRATCH_FILE_URL" value="file://$APPLICATION_CONFIG_DIR$/scratches/scratch.java" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="SegmentTree" type="Java Scratch" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="SegmentTree" />
      <option name="SCRATCH_FILE_URL" value="file://$APPLICATION_CONFIG_DIR$/scratches/scratch_1.java" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <list>
      <item itemvalue="Application.Main" />
      <item itemvalue="Application.DivideChocolates" />
      <item itemvalue="Java Scratch.Scratch (1)" />
      <item itemvalue="Java Scratch.SegmentTree" />
      <item itemvalue="Java Scratch.Scratch" />
      <item itemvalue="JUnit.Unnamed" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Java Scratch.Scratch" />
        <item itemvalue="Application.DivideChocolates" />
        <item itemvalue="Java Scratch.SegmentTree" />
        <item itemvalue="Java Scratch.Scratch (1)" />
        <item itemvalue="Application.Main" />
      </list>
    </recent_temporary>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="project-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7dbb84ff-cb70-4f33-84ac-c2138746d980" name="Default Changelist" comment="" />
      <created>1561288929632</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1561288929632</updated>
    </task>
    <task id="LOCAL-00564" summary="Solve medium and tricky problem, find the minimum speed to eat all the bananas in &lt;= h hours using binary search&#10;&#10;Learnings -- If the output can be either 1,2,3...n and verifying whether the target satisfies the input constraint takes linear time, we can apply binary search.">
      <created>1606838585386</created>
      <option name="number" value="00564" />
      <option name="presentableId" value="LOCAL-00564" />
      <option name="project" value="LOCAL" />
      <updated>1606838585386</updated>
    </task>
    <task id="LOCAL-00565" summary="Add gotcha in finding the min subarray that needs to be removed to make the remaining subarray sum divisible by p">
      <created>1606858613370</created>
      <option name="number" value="00565" />
      <option name="presentableId" value="LOCAL-00565" />
      <option name="project" value="LOCAL" />
      <updated>1606858613370</updated>
    </task>
    <task id="LOCAL-00566" summary="Solve hard and tricky find the longest repeated substring in string using binary search + rolling hash&#10;&#10;Binary search was not that difficult to identify but rolling hash took a lot of time due to modulo arithmetic in handling negative hashes. Also care must be taken to properly calculate new hash. Take care of indices and the multiplication factor.&#10;&#10;LCS can also be used to find the answer but it would have been n^2 and would have timed out due to higher input bound">
      <created>1606859023097</created>
      <option name="number" value="00566" />
      <option name="presentableId" value="LOCAL-00566" />
      <option name="project" value="LOCAL" />
      <updated>1606859023097</updated>
    </task>
    <task id="LOCAL-00567" summary="Solve medium find longest subarray that sums to a target value using prefix sum + hashmap&#10;&#10;Leveraged prior learnings of using prefix sum to deal with subarray sum problems. Only trick here was not updating the prefixsum in case an index with same prefix sum already exists -- this will help in finding the longest subarray">
      <created>1606861369842</created>
      <option name="number" value="00567" />
      <option name="presentableId" value="LOCAL-00567" />
      <option name="project" value="LOCAL" />
      <updated>1606861369842</updated>
    </task>
    <task id="LOCAL-00568" summary="Solve medium pick a random node from an infinitely long list using reservoir sampling. Fix the first kth element in the reservoir, then for the next element, put it in the reservoir only if the randomIndex is &lt; k. RandomIndex is [0, currentIndex)">
      <created>1606920086508</created>
      <option name="number" value="00568" />
      <option name="presentableId" value="LOCAL-00568" />
      <option name="project" value="LOCAL" />
      <updated>1606920086508</updated>
    </task>
    <task id="LOCAL-00569" summary="Solve medium design search suggestion system where given a search word, list all the products that start with each prefix of the search word using trie&#10;&#10;Leveraged prior learnings of storing useful information directly in trie node to avoid DFS">
      <created>1606925195595</created>
      <option name="number" value="00569" />
      <option name="presentableId" value="LOCAL-00569" />
      <option name="project" value="LOCAL" />
      <updated>1606925195595</updated>
    </task>
    <task id="LOCAL-00570" summary="Solve medium and a bit tricky find the longest chain of words that extend previous word by adding one character anywhere in previous word by either looking for next words in chain or previous words in chain.&#10;&#10;Looking for next words takes time because we have to generate all combinations to see whether such word exists or not, Looking for previous words is much faster">
      <created>1607008230899</created>
      <option name="number" value="00570" />
      <option name="presentableId" value="LOCAL-00570" />
      <option name="project" value="LOCAL" />
      <updated>1607008230900</updated>
    </task>
    <task id="LOCAL-00571" summary="Solve medium and a bit tricky find the shortest path of moving from one letter to another provided a string and a board of letters.&#10;&#10;Initially I thought of using BFS from prev letter to current letter, but then thought that comparing previous location with current location would suffice. Only thing that caused trouble was Z as from Z we have to move up first, then right.&#10;If we have to reach Z, we have to move left first, then down.">
      <created>1607009894579</created>
      <option name="number" value="00571" />
      <option name="presentableId" value="LOCAL-00571" />
      <option name="project" value="LOCAL" />
      <updated>1607009894579</updated>
    </task>
    <task id="LOCAL-00572" summary="Solve medium and math related divisibility problem, find count of pairs of numbers that are divisible by 60 by finding pairs of numbers whose mod sum = 60, This is similar to 2Sum Problem where we have to find two numbers such that a + b = k&#10;&#10;Take care of duplicates. Either use binary search or hashmap to count pairs.">
      <created>1607011464342</created>
      <option name="number" value="00572" />
      <option name="presentableId" value="LOCAL-00572" />
      <option name="project" value="LOCAL" />
      <updated>1607011464342</updated>
    </task>
    <task id="LOCAL-00573" summary="Solve medium and math related tricky 2D matrix problem, find the sum of all elements from (r1, c1) till (r2, c2) using 2D prefix sum&#10;&#10;Really happy to solve this question in first attempt, took me some time to visualize the prefix sum logic and conditions. Verified it manually on paper, only after that started coding. Woooohooo.">
      <created>1607014680713</created>
      <option name="number" value="00573" />
      <option name="presentableId" value="LOCAL-00573" />
      <option name="project" value="LOCAL" />
      <updated>1607014680713</updated>
    </task>
    <task id="LOCAL-00574" summary="Solve medium and tricky graph theory problem, find a way to visit each edge exactly once such the path is lexicographically smallest by greedy backtracking and using hierholzer algorithm to find the eulerian path of the graph&#10;&#10;Learnings -- Visiting each edge exactly once is well known graph theory problem known as eulerian path/cycle. It can be found by doing a postorder traversal of the graph, similar to the way we perform topological sorting using stack.&#10;&#10;Make sure to account for parallel edges/duplicate edges in graph problems unless specified. If there is duplicate edges, solve them by creating a key for each edge (src-&gt;target) and tracking their count. Decrement the count, when we visit a edge.">
      <created>1607112348672</created>
      <option name="number" value="00574" />
      <option name="presentableId" value="LOCAL-00574" />
      <option name="project" value="LOCAL" />
      <updated>1607112348672</updated>
    </task>
    <task id="LOCAL-00575" summary="Solve hard and extremely tricky divide and conquer problem, find the max profit after bursting balloons. Was asked this question in Zeta onsite back in 2019. &#10;&#10;Atleast this time I was able to solve using backtracking :P&#10;&#10;Learnings -- Divide and conquer and greedy are tough sons of bitches.">
      <created>1607172855612</created>
      <option name="number" value="00575" />
      <option name="presentableId" value="LOCAL-00575" />
      <option name="project" value="LOCAL" />
      <updated>1607172855612</updated>
    </task>
    <task id="LOCAL-00576" summary="Solve medium find the longest arithmetic subsequence in an array using the same concept as LIS. Was able to think about the n^2 solution instantaneously :P Sometimes I feel like a genius">
      <created>1607173223412</created>
      <option name="number" value="00576" />
      <option name="presentableId" value="LOCAL-00576" />
      <option name="project" value="LOCAL" />
      <updated>1607173223412</updated>
    </task>
    <task id="LOCAL-00577" summary="Solve medium and a bit tricky problem, find the total probability of knight remaining on the chessboard after making k moves. &#10;&#10;I am a bit surprised to do this in first attempt. Think I am getting a little good :P &#10;&#10;A gotcha to make the solution memoizable is to return results of each subproblem independently of another. Initially I was thinking of passing in the current prob as a prefix multiplier but then discarded it">
      <created>1607176110831</created>
      <option name="number" value="00577" />
      <option name="presentableId" value="LOCAL-00577" />
      <option name="project" value="LOCAL" />
      <updated>1607176110832</updated>
    </task>
    <task id="LOCAL-00578" summary="Add clarification on why visited array isn't required in problems with max steps/length permissible">
      <created>1607181527763</created>
      <option name="number" value="00578" />
      <option name="presentableId" value="LOCAL-00578" />
      <option name="project" value="LOCAL" />
      <updated>1607181527763</updated>
    </task>
    <task id="LOCAL-00579" summary="Solve medium find the total no of ways of reaching outside the grid given we can only traverse finite number of steps using DFS + Memoization.&#10;&#10;Leveraged prior learnings of solving problems related to finding total no of ways of doing something by returning 1 only at the end state and keeping track of total no of ways at each step.">
      <created>1607182032394</created>
      <option name="number" value="00579" />
      <option name="presentableId" value="LOCAL-00579" />
      <option name="project" value="LOCAL" />
      <updated>1607182032394</updated>
    </task>
    <task id="LOCAL-00580" summary="Add a bit of clarification regarding greedy way of generating euler path over backtracking approach">
      <created>1607196989700</created>
      <option name="number" value="00580" />
      <option name="presentableId" value="LOCAL-00580" />
      <option name="project" value="LOCAL" />
      <updated>1607196989700</updated>
    </task>
    <task id="LOCAL-00581" summary="Solve hard and extremely trick problem, find the shortest string that contains all permutation of n digits of numbers containing k digits by modelling it as a fucking graph and doing backtracking to generate euler path that visits all edges exactly once.&#10;&#10;I could not think of modelling it as a graph during the thought process, I started to solve it using Trie as it involves prefixes.">
      <created>1607197150070</created>
      <option name="number" value="00581" />
      <option name="presentableId" value="LOCAL-00581" />
      <option name="project" value="LOCAL" />
      <updated>1607197150070</updated>
    </task>
    <task id="LOCAL-00582" summary="Fix grammatical mistake">
      <created>1607270051315</created>
      <option name="number" value="00582" />
      <option name="presentableId" value="LOCAL-00582" />
      <option name="project" value="LOCAL" />
      <updated>1607270051315</updated>
    </task>
    <task id="LOCAL-00583" summary="Add clarification around why changing the problem statement to &quot;non-decreasing&quot; can introduce cycles in the graph, possibly increasing the time complexity">
      <created>1607288914813</created>
      <option name="number" value="00583" />
      <option name="presentableId" value="LOCAL-00583" />
      <option name="project" value="LOCAL" />
      <updated>1607288914813</updated>
    </task>
    <task id="LOCAL-00584" summary="Solve medium and extremely tricky problem, find the path with maximum minimum value possible from source to target in a grid using &#10; 3 approaches: binary search or priority queue or union find&#10; &#10;Learnings -- In case of grid problems where traversal in 4 direction is permissible make sure to handle cycles. If you are memoizing the solution, make sure the memoized value does not depend upon the initial path that was taken to visit that cell. &#10;&#10;Binary search is to go to approach for dealing with maximum minimum problems">
      <created>1607289096122</created>
      <option name="number" value="00584" />
      <option name="presentableId" value="LOCAL-00584" />
      <option name="project" value="LOCAL" />
      <updated>1607289096122</updated>
    </task>
    <task id="LOCAL-00585" summary="Solve medium and extremely tricky problem, find the path with minimum effort. Effort here is the max diff between two adjacent elements. Multiple ways of solving this problem, Djikstra, Binary Search or Union Find.">
      <created>1607360079377</created>
      <option name="number" value="00585" />
      <option name="presentableId" value="LOCAL-00585" />
      <option name="project" value="LOCAL" />
      <updated>1607360079377</updated>
    </task>
    <task id="LOCAL-00586" summary="Solve medium and extremely tricky problem, find the lexicographically smallest string that is possible by swapping pairs of provided indices any number of times by reducing the problem to connected components. Characters in every component can be sorted individually to get the result.&#10;&#10;I tried solving using greedy but couldn't make it work.">
      <created>1607365896921</created>
      <option name="number" value="00586" />
      <option name="presentableId" value="LOCAL-00586" />
      <option name="project" value="LOCAL" />
      <updated>1607365896921</updated>
    </task>
    <task id="LOCAL-00587" summary="Solve medium find the number of 1s that does not have 1 in the same row and same column by keeping track of 1's encountered in each row and each column">
      <created>1607366692107</created>
      <option name="number" value="00587" />
      <option name="presentableId" value="LOCAL-00587" />
      <option name="project" value="LOCAL" />
      <updated>1607366692107</updated>
    </task>
    <task id="LOCAL-00588" summary="Solve medium find the only edge that is introducing cycles in the tree by using union find algorithm">
      <created>1607434287449</created>
      <option name="number" value="00588" />
      <option name="presentableId" value="LOCAL-00588" />
      <option name="project" value="LOCAL" />
      <updated>1607434287449</updated>
    </task>
    <task id="LOCAL-00589" summary="Solve medium find the max time required to send message from a node to all other nodes using djikstra algorithm">
      <created>1607434806472</created>
      <option name="number" value="00589" />
      <option name="presentableId" value="LOCAL-00589" />
      <option name="project" value="LOCAL" />
      <updated>1607434806472</updated>
    </task>
    <task id="LOCAL-00590" summary="Add hint of using binary search as an alternate way of solving this problem">
      <created>1607437187778</created>
      <option name="number" value="00590" />
      <option name="presentableId" value="LOCAL-00590" />
      <option name="project" value="LOCAL" />
      <updated>1607437187779</updated>
    </task>
    <task id="LOCAL-00591" summary="Add missing sample input to the problem statement">
      <created>1607441323391</created>
      <option name="number" value="00591" />
      <option name="presentableId" value="LOCAL-00591" />
      <option name="project" value="LOCAL" />
      <updated>1607441323391</updated>
    </task>
    <task id="LOCAL-00592" summary="Add clarification around why boolean flag was not memoized, because two players can't have the same state ever.">
      <created>1607452230099</created>
      <option name="number" value="00592" />
      <option name="presentableId" value="LOCAL-00592" />
      <option name="project" value="LOCAL" />
      <updated>1607452230099</updated>
    </task>
    <task id="LOCAL-00593" summary="Solve medium swap nodes in linked list in pair, a bit tricky as it needed multiple pointers to keep track of first and second node of current block and start of next block.&#10;&#10;As usual keep a dummy pointer to make your life easier while manipulating linked list">
      <created>1607612473932</created>
      <option name="number" value="00593" />
      <option name="presentableId" value="LOCAL-00593" />
      <option name="project" value="LOCAL" />
      <updated>1607612473932</updated>
    </task>
    <task id="LOCAL-00594" summary="Simplify finding whether an array is a mountain array or not by reducing the problem to finding length of longest increasing subarray from left and right">
      <created>1607613521190</created>
      <option name="number" value="00594" />
      <option name="presentableId" value="LOCAL-00594" />
      <option name="project" value="LOCAL" />
      <updated>1607613521190</updated>
    </task>
    <task id="LOCAL-00595" summary="Solve medium implement an iterator for iterating BST in inorder traversal. My implementation took o(n) space as I dumped all the contents of BST in a linked list but it can be optimized to o(h) space by doing iterative inorder traversal.">
      <created>1607614940109</created>
      <option name="number" value="00595" />
      <option name="presentableId" value="LOCAL-00595" />
      <option name="project" value="LOCAL" />
      <updated>1607614940109</updated>
    </task>
    <task id="LOCAL-00596" summary="Solve medium remove duplicates from a sorted array in place by overwriting the duplicate values with INFINITY in first pass. In second pass, we overwrite the index only if current value is not INFINITY&#10;&#10;In my initial solution after overwriting to INFINITY, I directly sorted the array to make the larger values go at the end.">
      <created>1607717198153</created>
      <option name="number" value="00596" />
      <option name="presentableId" value="LOCAL-00596" />
      <option name="project" value="LOCAL" />
      <updated>1607717198153</updated>
    </task>
    <task id="LOCAL-00597" summary="Solve medium and tricky tree problem, find the lca of all nodes present at the last level using 2 pass approach. &#10;1st pass to find the max depth. 2nd pass to find whether the left/right subtree of current node are at the max depth, if yes, current node is a candidate lca.">
      <created>1607771807171</created>
      <option name="number" value="00597" />
      <option name="presentableId" value="LOCAL-00597" />
      <option name="project" value="LOCAL" />
      <updated>1607771807171</updated>
    </task>
    <task id="LOCAL-00598" summary="Add reference of another question discussed on discuss related to finding min operations required to flip an boolean expression by divide and conquer strategy.&#10;&#10;Learnings -- In case of problems related with expression, divide and conquer seems to be the optimal strategy as it divides the problem into independent subproblem">
      <created>1607858015064</created>
      <option name="number" value="00598" />
      <option name="presentableId" value="LOCAL-00598" />
      <option name="project" value="LOCAL" />
      <updated>1607858015065</updated>
    </task>
    <task id="LOCAL-00599" summary="Solve hard and tricky find the minimum time required to reach target node given you can traverse a cell only if current time &gt;= cell value. We need to minimize the total time required. So we need to minimize the largest value in the path.&#10;&#10;Leveraged prior learnings of solving this problems using Greedy/Djikstra. Reminder to myself to not use Djikstra to solve path with maximum total cost / PathWithMaximumGold">
      <created>1607861774773</created>
      <option name="number" value="00599" />
      <option name="presentableId" value="LOCAL-00599" />
      <option name="project" value="LOCAL" />
      <updated>1607861774774</updated>
    </task>
    <task id="LOCAL-00600" summary="Solve medium and tricky find the path with the largest total cost. In my initial implementation, I used Djikstra where I greedily pick the largest node but realized that it gave WA for some test cases. &#10;&#10;Learnings -- Use greedy as an optimization for backtracking w/o pruning only if the input constraints are high. In this case, there are only 25 cells with gold, so backtracking was an hint. &#10;Also Djikstra can't be used to find path with the largest total distance.">
      <created>1607862237434</created>
      <option name="number" value="00600" />
      <option name="presentableId" value="LOCAL-00600" />
      <option name="project" value="LOCAL" />
      <updated>1607862237435</updated>
    </task>
    <task id="LOCAL-00601" summary="Solve medium and tricky find the sum of absolute differences of an index with all other indexes in an array by considering the contribution of each index separately. Find the contribution by summing up contribution of left and right subarray.">
      <created>1607870150243</created>
      <option name="number" value="00601" />
      <option name="presentableId" value="LOCAL-00601" />
      <option name="project" value="LOCAL" />
      <updated>1607870150243</updated>
    </task>
    <task id="LOCAL-00602" summary="Solve hard and extremely trick problem find the smallest no of squares to completely fill a rectangle by backtracking with pruning.&#10;&#10;Learnings -- 1. Backtracking solution was a bit difficult to visualize initially.&#10;2. During pruning, it's efficient to take the possible biggest steps first to prune a lot of branches faster.">
      <created>1607876545023</created>
      <option name="number" value="00602" />
      <option name="presentableId" value="LOCAL-00602" />
      <option name="project" value="LOCAL" />
      <updated>1607876545023</updated>
    </task>
    <task id="LOCAL-00603" summary="Solve easy find the node with the value that is closest to the target in BST by recursion and keeping track of the minDiff found so far">
      <created>1607876836364</created>
      <option name="number" value="00603" />
      <option name="presentableId" value="LOCAL-00603" />
      <option name="project" value="LOCAL" />
      <updated>1607876836364</updated>
    </task>
    <task id="LOCAL-00604" summary="Solve hard problem which reduces to split the array into d subarrays such that sum of maximum of each subarray is minimized by recursion + memoization.&#10;&#10;Leveraged prior learnings of solving such problems by making cuts at all possible places and keeping track of min sum so far.">
      <created>1607881661086</created>
      <option name="number" value="00604" />
      <option name="presentableId" value="LOCAL-00604" />
      <option name="project" value="LOCAL" />
      <updated>1607881661086</updated>
    </task>
    <task id="LOCAL-00605" summary="Add gotcha during deletion of index from list as deletion of any index other that last index takes linear time, so first swap the value to the last index and then always delete the last index.">
      <created>1607883182482</created>
      <option name="number" value="00605" />
      <option name="presentableId" value="LOCAL-00605" />
      <option name="project" value="LOCAL" />
      <updated>1607883182482</updated>
    </task>
    <task id="LOCAL-00606" summary="Solve hard and tricky design data structure which supports insert delete getRandom in O(1) time. List already supports insert and getRandom() in constant time but to delete elements, we need to know the index at which it occurs. We can keep a map to lookup the required index. In order to keep constant time for deletion, need to make sure we delete only from the last to avoid o(n) penalty for deletion in between. Hence swap out the element at last index with value to be removed during deletion.">
      <created>1607956372268</created>
      <option name="number" value="00606" />
      <option name="presentableId" value="LOCAL-00606" />
      <option name="project" value="LOCAL" />
      <updated>1607956372269</updated>
    </task>
    <task id="LOCAL-00607" summary="Solve hard find the no of envelopes that can fit inside one another -- variant of finding LIS for 2D array">
      <created>1607957933101</created>
      <option name="number" value="00607" />
      <option name="presentableId" value="LOCAL-00607" />
      <option name="project" value="LOCAL" />
      <updated>1607957933101</updated>
    </task>
    <task id="LOCAL-00608" summary="Solve medium add one to linked list by using recursion as the implicit stack to pass carry digit to the previous node.">
      <created>1608038346241</created>
      <option name="number" value="00608" />
      <option name="presentableId" value="LOCAL-00608" />
      <option name="project" value="LOCAL" />
      <updated>1608038346242</updated>
    </task>
    <task id="LOCAL-00609" summary="Solve hard and extremely trick problem of finding shortest path that visits all nodes such that a node can be visited multiple times using BFS + Bitmasking&#10;&#10;First saw this problem in september, couldn't understand it a bit. Saw a similar problem recently PathWithMaximumGold in which one guy solved it similar to solving this problem. Revisited this problem and could now make sense of the provided solution. Practice makes a man perfect !&#10;&#10;Key thing to note is use BFS for finding shortest path and use set of visited nodes (bitmask) + current node as the key for determining already visited paths.">
      <created>1608044680373</created>
      <option name="number" value="00609" />
      <option name="presentableId" value="LOCAL-00609" />
      <option name="project" value="LOCAL" />
      <updated>1608044680373</updated>
    </task>
    <task id="LOCAL-00610" summary="Solve medium and tricky find the largest subset in which each pair of elements divide each other by sorting + checking whether current number can extend result stored in previous index&#10;&#10;Learnings -- In case of subset problems, order isn't important, so check if sorting helps! I was on the right track but didn't sort, hence got WA and then became confused.">
      <created>1608051958267</created>
      <option name="number" value="00610" />
      <option name="presentableId" value="LOCAL-00610" />
      <option name="project" value="LOCAL" />
      <updated>1608051958268</updated>
    </task>
    <task id="LOCAL-00611" summary="Solve medium find the no of tuples A,B,C,D in 4 arrays such that sum of tuples is 0 by storing pair wise sum of A+B in one hashmap and pair wise sum of C+D in another hashmap">
      <created>1608221116162</created>
      <option name="number" value="00611" />
      <option name="presentableId" value="LOCAL-00611" />
      <option name="project" value="LOCAL" />
      <updated>1608221116162</updated>
    </task>
    <task id="LOCAL-00612" summary="Solve medium find the earliest moment when everyone becomes friend i.e. when there is only one unique component left using Union Find&#10;&#10;Learnings -- We can stop when uniqueComponents == 1 (init it with N and decrement everytime you perform a union) or when size[root] == N (the last union performed had all the elements in the subtree)">
      <created>1608224202639</created>
      <option name="number" value="00612" />
      <option name="presentableId" value="LOCAL-00612" />
      <option name="project" value="LOCAL" />
      <updated>1608224202639</updated>
    </task>
    <option name="localTasksCounter" value="613" />
    <servers />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="1">
          <value>
            <State>
              <option name="FILTERS">
                <map>
                  <entry key="roots">
                    <value>
                      <list>
                        <option value="$PROJECT_DIR$" />
                      </list>
                    </value>
                  </entry>
                </map>
              </option>
            </State>
          </value>
        </entry>
        <entry key="2">
          <value>
            <State>
              <option name="FILTERS">
                <map>
                  <entry key="roots">
                    <value>
                      <list>
                        <option value="$PROJECT_DIR$" />
                      </list>
                    </value>
                  </entry>
                  <entry key="text">
                    <value>
                      <list>
                        <option value="hard and tricky" />
                      </list>
                    </value>
                  </entry>
                  <entry key="user">
                    <value>
                      <list>
                        <option value="snehasishiiita" />
                      </list>
                    </value>
                  </entry>
                </map>
              </option>
            </State>
          </value>
        </entry>
        <entry key="MAIN">
          <value>
            <State />
          </value>
        </entry>
      </map>
    </option>
    <option name="oldMeFiltersMigrated" value="true" />
  </component>
  <component name="VcsManagerConfiguration">
    <option name="CHECK_CODE_CLEANUP_BEFORE_PROJECT_COMMIT" value="true" />
    <MESSAGE value="Solve medium find the only edge that is introducing cycles in the tree by using union find algorithm" />
    <MESSAGE value="Solve medium find the max time required to send message from a node to all other nodes using djikstra algorithm" />
    <MESSAGE value="Add hint of using binary search as an alternate way of solving this problem" />
    <MESSAGE value="Add missing sample input to the problem statement" />
    <MESSAGE value="Add clarification around why boolean flag was not memoized, because two players can't have the same state ever." />
    <MESSAGE value="Solve medium swap nodes in linked list in pair, a bit tricky as it needed multiple pointers to keep track of first and second node of current block and start of next block.&#10;&#10;As usual keep a dummy pointer to make your life easier while manipulating linked list" />
    <MESSAGE value="Simplify finding whether an array is a mountain array or not by reducing the problem to finding length of longest increasing subarray from left and right" />
    <MESSAGE value="Solve medium implement an iterator for iterating BST in inorder traversal. My implementation took o(n) space as I dumped all the contents of BST in a linked list but it can be optimized to o(h) space by doing iterative inorder traversal." />
    <MESSAGE value="Solve medium remove duplicates from a sorted array in place by overwriting the duplicate values with INFINITY in first pass. In second pass, we overwrite the index only if current value is not INFINITY&#10;&#10;In my initial solution after overwriting to INFINITY, I directly sorted the array to make the larger values go at the end." />
    <MESSAGE value="Solve medium and tricky tree problem, find the lca of all nodes present at the last level using 2 pass approach. &#10;1st pass to find the max depth. 2nd pass to find whether the left/right subtree of current node are at the max depth, if yes, current node is a candidate lca." />
    <MESSAGE value="Add reference of another question discussed on discuss related to finding min operations required to flip an boolean expression by divide and conquer strategy.&#10;&#10;Learnings -- In case of problems related with expression, divide and conquer seems to be the optimal strategy as it divides the problem into independent subproblem" />
    <MESSAGE value="Solve hard and tricky find the minimum time required to reach target node given you can traverse a cell only if current time &gt;= cell value. We need to minimize the total time required. So we need to minimize the largest value in the path.&#10;&#10;Leveraged prior learnings of solving this problems using Greedy/Djikstra. Reminder to myself to not use Djikstra to solve path with maximum total cost / PathWithMaximumGold" />
    <MESSAGE value="Solve medium and tricky find the path with the largest total cost. In my initial implementation, I used Djikstra where I greedily pick the largest node but realized that it gave WA for some test cases. &#10;&#10;Learnings -- Use greedy as an optimization for backtracking w/o pruning only if the input constraints are high. In this case, there are only 25 cells with gold, so backtracking was an hint. &#10;Also Djikstra can't be used to find path with the largest total distance." />
    <MESSAGE value="Solve medium and tricky find the sum of absolute differences of an index with all other indexes in an array by considering the contribution of each index separately. Find the contribution by summing up contribution of left and right subarray." />
    <MESSAGE value="Solve hard and extremely trick problem find the smallest no of squares to completely fill a rectangle by backtracking with pruning.&#10;&#10;Learnings -- 1. Backtracking solution was a bit difficult to visualize initially.&#10;2. During pruning, it's efficient to take the possible biggest steps first to prune a lot of branches faster." />
    <MESSAGE value="Solve easy find the node with the value that is closest to the target in BST by recursion and keeping track of the minDiff found so far" />
    <MESSAGE value="Solve hard problem which reduces to split the array into d subarrays such that sum of maximum of each subarray is minimized by recursion + memoization.&#10;&#10;Leveraged prior learnings of solving such problems by making cuts at all possible places and keeping track of min sum so far." />
    <MESSAGE value="Add gotcha during deletion of index from list as deletion of any index other that last index takes linear time, so first swap the value to the last index and then always delete the last index." />
    <MESSAGE value="Solve hard and tricky design data structure which supports insert delete getRandom in O(1) time. List already supports insert and getRandom() in constant time but to delete elements, we need to know the index at which it occurs. We can keep a map to lookup the required index. In order to keep constant time for deletion, need to make sure we delete only from the last to avoid o(n) penalty for deletion in between. Hence swap out the element at last index with value to be removed during deletion." />
    <MESSAGE value="Solve hard find the no of envelopes that can fit inside one another -- variant of finding LIS for 2D array" />
    <MESSAGE value="Solve medium add one to linked list by using recursion as the implicit stack to pass carry digit to the previous node." />
    <MESSAGE value="Solve hard and extremely trick problem of finding shortest path that visits all nodes such that a node can be visited multiple times using BFS + Bitmasking&#10;&#10;First saw this problem in september, couldn't understand it a bit. Saw a similar problem recently PathWithMaximumGold in which one guy solved it similar to solving this problem. Revisited this problem and could now make sense of the provided solution. Practice makes a man perfect !&#10;&#10;Key thing to note is use BFS for finding shortest path and use set of visited nodes (bitmask) + current node as the key for determining already visited paths." />
    <MESSAGE value="Solve medium and tricky find the largest subset in which each pair of elements divide each other by sorting + checking whether current number can extend result stored in previous index&#10;&#10;Learnings -- In case of subset problems, order isn't important, so check if sorting helps! I was on the right track but didn't sort, hence got WA and then became confused." />
    <MESSAGE value="Solve medium find the no of tuples A,B,C,D in 4 arrays such that sum of tuples is 0 by storing pair wise sum of A+B in one hashmap and pair wise sum of C+D in another hashmap" />
    <MESSAGE value="Solve medium find the earliest moment when everyone becomes friend i.e. when there is only one unique component left using Union Find&#10;&#10;Learnings -- We can stop when uniqueComponents == 1 (init it with N and decrement everytime you perform a union) or when size[root] == N (the last union performed had all the elements in the subtree)" />
    <option name="LAST_COMMIT_MESSAGE" value="Solve medium find the earliest moment when everyone becomes friend i.e. when there is only one unique component left using Union Find&#10;&#10;Learnings -- We can stop when uniqueComponents == 1 (init it with N and decrement everytime you perform a union) or when size[root] == N (the last union performed had all the elements in the subtree)" />
    <option name="OPTIMIZE_IMPORTS_BEFORE_PROJECT_COMMIT" value="true" />
    <option name="REFORMAT_BEFORE_PROJECT_COMMIT" value="true" />
    <option name="REARRANGE_BEFORE_PROJECT_COMMIT" value="true" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/DistinctSubsequences.java</url>
          <line>78</line>
          <option name="timeStamp" value="1" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/SortColors.java</url>
          <line>29</line>
          <option name="timeStamp" value="2" />
        </line-breakpoint>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/GeneralizedAbbreviations.java</url>
          <line>33</line>
          <option name="timeStamp" value="8" />
        </line-breakpoint>
      </breakpoints>
      <default-breakpoints>
        <breakpoint enabled="true" type="java-exception">
          <condition expression="this instanceof StringIndexOutOfBoundsException" language="JAVA" />
          <properties>
            <catch-class-filters>
              <class-filter pattern="java.lang.ArrayIndexOutOfBoundsException" />
            </catch-class-filters>
          </properties>
        </breakpoint>
      </default-breakpoints>
    </breakpoint-manager>
    <watches-manager>
      <configuration name="JUnit">
        <watch expression="grid" />
        <watch expression="uniqueString.entrySet().toArray()[0]" />
      </configuration>
    </watches-manager>
  </component>
  <component name="XSLT-Support.FileAssociations.UIState">
    <expand />
    <select />
  </component>
</project>