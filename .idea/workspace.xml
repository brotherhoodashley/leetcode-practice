<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="BranchesTreeState">
    <expand />
    <select>
      <path>
        <item name="ROOT" type="e8cecc67:BranchNodeDescriptor" />
        <item name="LOCAL_ROOT" type="e8cecc67:BranchNodeDescriptor" />
      </path>
    </select>
  </component>
  <component name="ChangeListManager">
    <list default="true" id="7dbb84ff-cb70-4f33-84ac-c2138746d980" name="Default Changelist" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DefaultGradleProjectSettings">
    <option name="isMigrated" value="true" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="JUnit5 Test Class" />
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
    <option name="PUSH_TAGS">
      <GitPushTagMode />
    </option>
  </component>
  <component name="GithubPullRequestsUISettings">
    <option name="hiddenUrls">
      <set>
        <option value="https://github.com/snehasishroy/leetcode-practice.git" />
      </set>
    </option>
  </component>
  <component name="MavenImportPreferences">
    <option name="importingSettings">
      <MavenImportingSettings>
        <option name="vmOptionsForImporter" value="-Xmx768m" />
      </MavenImportingSettings>
    </option>
  </component>
  <component name="ProjectId" id="1OYjUozR2wA5XfxN4lSupdXEdA9" />
  <component name="ProjectLevelVcsManager">
    <ConfirmationsSetting value="1" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">
    <property name="Downloaded.Files.Path.Enabled" value="false" />
    <property name="Repository.Attach.Annotations" value="true" />
    <property name="Repository.Attach.JavaDocs" value="true" />
    <property name="Repository.Attach.Sources" value="true" />
    <property name="RunOnceActivity.OpenProjectViewOnStart" value="true" />
    <property name="SHARE_PROJECT_CONFIGURATION_FILES" value="true" />
    <property name="ToolWindowRun.ShowToolbar" value="false" />
    <property name="com.intellij.ide.scratch.LRUPopupBuilder$1/New Scratch File" value="JAVA" />
    <property name="com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrary" value="JUnit5" />
    <property name="com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrarySuperClass.JUnit5" value="" />
    <property name="extract.method.default.visibility" value="private" />
    <property name="last.edited.regexp" value="abc\ntasd\n" />
    <property name="last_directory_selection" value="$PROJECT_DIR$/src/main/java/common" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="project.structure.last.edited" value="Modules" />
    <property name="project.structure.proportion" value="0.15" />
    <property name="project.structure.side.proportion" value="0.2" />
    <property name="restartRequiresConfirmation" value="false" />
    <property name="settings.editor.selected.configurable" value="com.codota.intellij.common.configuration.CodotaConfigurable" />
  </component>
  <component name="RecentsManager">
    <key name="CreateTestDialog.RecentsKey">
      <recent name="" />
    </key>
    <key name="MoveClassesOrPackagesDialog.RECENTS_KEY">
      <recent name="" />
      <recent name="alternate" />
      <recent name="common" />
    </key>
    <key name="MoveInnerDialog.RECENTS_KEY">
      <recent name="common" />
    </key>
    <key name="CopyClassDialog.RECENTS_KEY">
      <recent name="" />
    </key>
    <key name="CreateTestDialog.Recents.Supers">
      <recent name="" />
    </key>
  </component>
  <component name="RunManager" selected="Application.PredictTheWinner">
    <configuration name="CanIWin" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="CanIWin" />
      <module name="leetcode-practice" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="DistinctSubsequences" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="DistinctSubsequences" />
      <module name="leetcode-practice" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="PredictTheWinner" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="PredictTheWinner" />
      <module name="leetcode-practice" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="SudokuSolver" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="SudokuSolver" />
      <module name="leetcode-practice" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Unnamed" type="JUnit" factoryName="JUnit" nameIsGenerated="true">
      <module name="leetcode-practice" />
      <option name="MAIN_CLASS_NAME" value="" />
      <option name="METHOD_NAME" value="" />
      <option name="TEST_OBJECT" value="class" />
      <option name="PARAMETERS" value="" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Scratch" type="Java Scratch" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="Scratch" />
      <option name="SCRATCH_FILE_URL" value="file://$APPLICATION_CONFIG_DIR$/scratches/scratch.java" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <list>
      <item itemvalue="Application.DistinctSubsequences" />
      <item itemvalue="Application.SudokuSolver" />
      <item itemvalue="Application.CanIWin" />
      <item itemvalue="Java Scratch.Scratch" />
      <item itemvalue="JUnit.Unnamed" />
      <item itemvalue="Application.PredictTheWinner" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Application.PredictTheWinner" />
        <item itemvalue="Application.CanIWin" />
        <item itemvalue="Java Scratch.Scratch" />
        <item itemvalue="Application.SudokuSolver" />
        <item itemvalue="Application.DistinctSubsequences" />
      </list>
    </recent_temporary>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="project-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="7dbb84ff-cb70-4f33-84ac-c2138746d980" name="Default Changelist" comment="" />
      <created>1561288929632</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1561288929632</updated>
    </task>
    <task id="LOCAL-00461" summary="Solve medium find length of the longest consecutive sequence in a binary tree by passing information to the child.&#10;&#10;Child needs to know what is the length of the consecutive sequence present at parent and decide whether it can extend it or not.">
      <created>1604070480173</created>
      <option name="number" value="00461" />
      <option name="presentableId" value="LOCAL-00461" />
      <option name="project" value="LOCAL" />
      <updated>1604070480174</updated>
    </task>
    <task id="LOCAL-00462" summary="Solve medium and a bit tricky find length of the longest increasing/decreasing consecutive sequence in a binary tree&#10;&#10;Since both increasing/decreasing sequence needs to be considered, parent node must be aware of the longest sequence ending/beginning at child node. This will ensure parent has the information to choose either of the path.">
      <created>1604091791761</created>
      <option name="number" value="00462" />
      <option name="presentableId" value="LOCAL-00462" />
      <option name="project" value="LOCAL" />
      <updated>1604091791762</updated>
    </task>
    <task id="LOCAL-00463" summary="Solve hard and a bit tricky to reduce time complexity, find two nodes whose values are swapped in a bst.&#10;&#10;This is similar to finding two elements in nearly sorted array that have been swapped. It's a classical problem that can be done in linear time without sorting the entire input using two pointers">
      <created>1604141274330</created>
      <option name="number" value="00463" />
      <option name="presentableId" value="LOCAL-00463" />
      <option name="project" value="LOCAL" />
      <updated>1604141274330</updated>
    </task>
    <task id="LOCAL-00464" summary="Solve medium and very interesting low level implementation problem, encode a list of strings to a single string that can be decoded to convert into list of strings.&#10;&#10;There are multiple ways to solve this question, use a delimiter outside of input char range, or escape the chosen delimiter if present in the input or use chunked transfer encoding">
      <created>1604143784957</created>
      <option name="number" value="00464" />
      <option name="presentableId" value="LOCAL-00464" />
      <option name="project" value="LOCAL" />
      <updated>1604143784957</updated>
    </task>
    <task id="LOCAL-00465" summary="Solve easy meeting rooms, check whether there is a conflict in the appointment.&#10;&#10;Leveraged prior learnings of MyCalendar1. Can also be done by sorting the entire array and then checking for conflicts.">
      <created>1604218374711</created>
      <option name="number" value="00465" />
      <option name="presentableId" value="LOCAL-00465" />
      <option name="project" value="LOCAL" />
      <updated>1604218374712</updated>
    </task>
    <task id="LOCAL-00466" summary="Solve medium but very tricky to optimize sentence screen fitting, fit a sentence into a grid such that a word can't be split across two rows. &#10;&#10;Learnings -- Deal with questions related to finding no of repetitions in a infinitely repeating sequence">
      <created>1604219833078</created>
      <option name="number" value="00466" />
      <option name="presentableId" value="LOCAL-00466" />
      <option name="project" value="LOCAL" />
      <updated>1604219833078</updated>
    </task>
    <task id="LOCAL-00467" summary="Solve hard find all possible subsequences of a target string in the source string by recursion.&#10;&#10;Initially I thought to implement it by storing indices of all target characters and look for a greater index than previous chosen index but sadly it timed out. (Similar to MinWindowSubsequence)&#10;&#10;Later I thought to implement it the classic way of solving problems related to two string, compare characters at two indices and update indices accordingly.">
      <created>1604238894584</created>
      <option name="number" value="00467" />
      <option name="presentableId" value="LOCAL-00467" />
      <option name="project" value="LOCAL" />
      <updated>1604238894584</updated>
    </task>
    <task id="LOCAL-00468" summary="Solve hard find all possible subsequences of a target string in the source string by recursion.&#10;&#10;Initially I thought to implement it by storing indices of all target characters and look for a greater index than previous chosen index but sadly it timed out. (Similar to MinWindowSubsequence)&#10;&#10;Later I thought to implement it the classic way of solving problems related to two string, compare characters at two indices and update indices accordingly.">
      <created>1604238913765</created>
      <option name="number" value="00468" />
      <option name="presentableId" value="LOCAL-00468" />
      <option name="project" value="LOCAL" />
      <updated>1604238913765</updated>
    </task>
    <task id="LOCAL-00469" summary="Simplify treeMap solution by directly adding element to the map if map is empty.">
      <created>1604240322069</created>
      <option name="number" value="00469" />
      <option name="presentableId" value="LOCAL-00469" />
      <option name="project" value="LOCAL" />
      <updated>1604240322070</updated>
    </task>
    <task id="LOCAL-00470" summary="Simplify code by removing complicated initial code and add approach in find maximum width of a binary tree">
      <created>1604243843120</created>
      <option name="number" value="00470" />
      <option name="presentableId" value="LOCAL-00470" />
      <option name="project" value="LOCAL" />
      <updated>1604243843120</updated>
    </task>
    <task id="LOCAL-00471" summary="Solve classical hard problem merge k sorted linked list using priority queue">
      <created>1604243949090</created>
      <option name="number" value="00471" />
      <option name="presentableId" value="LOCAL-00471" />
      <option name="project" value="LOCAL" />
      <updated>1604243949090</updated>
    </task>
    <task id="LOCAL-00472" summary="Solve hard problem find the longest substring with balanced '(' and ')' using two pass algorithm.&#10;&#10;First use stack to mark balanced indices, then find the longest subarray with all balanced index.&#10;&#10;Tried to initially solve the question via a lot of approaches, sliding window, prefix sum but it failed.&#10;&#10;This question can also be solved by using DP, care must be taken to carry forward the results which I missed.">
      <created>1604254094056</created>
      <option name="number" value="00472" />
      <option name="presentableId" value="LOCAL-00472" />
      <option name="project" value="LOCAL" />
      <updated>1604254094056</updated>
    </task>
    <task id="LOCAL-00473" summary="Solve medium sudoku solver using classic backtracking algorithm. Try to place candidates on an emptyIndex and recur for the remaining empty indices. If none of the candidates are safe to place, backtrack and unset a previously placed candidate.&#10;&#10;Care must be taken to properly backtrack all the associated datastructures as there are many in this case.">
      <created>1604261801290</created>
      <option name="number" value="00473" />
      <option name="presentableId" value="LOCAL-00473" />
      <option name="project" value="LOCAL" />
      <updated>1604261801290</updated>
    </task>
    <task id="LOCAL-00474" summary="Solve medium partition a binary tree into two subtree with equal sum using two pass algorithm. First find the total sum and then for each parent, check if the child subtree has half the total sum. If yes, cut that edge.&#10;&#10;Care must be taken to disambiguate null nodes vs nodes with val 0">
      <created>1604327792973</created>
      <option name="number" value="00474" />
      <option name="presentableId" value="LOCAL-00474" />
      <option name="project" value="LOCAL" />
      <updated>1604327792973</updated>
    </task>
    <task id="LOCAL-00475" summary="Solve medium tricky problem find longest substring with all unique characters repeating &gt;=k times.&#10;&#10;Sliding window technique is really odd and seems hacky. Recursive solution to create splits at invalid characters makes sense.">
      <created>1604347780478</created>
      <option name="number" value="00475" />
      <option name="presentableId" value="LOCAL-00475" />
      <option name="project" value="LOCAL" />
      <updated>1604347780478</updated>
    </task>
    <task id="LOCAL-00476" summary="Solve easy find average of top 5 scores of each student using counting sort.">
      <created>1604349401280</created>
      <option name="number" value="00476" />
      <option name="presentableId" value="LOCAL-00476" />
      <option name="project" value="LOCAL" />
      <updated>1604349401280</updated>
    </task>
    <task id="LOCAL-00477" summary="Rename file to match problem statement">
      <created>1604351241880</created>
      <option name="number" value="00477" />
      <option name="presentableId" value="LOCAL-00477" />
      <option name="project" value="LOCAL" />
      <updated>1604351241880</updated>
    </task>
    <task id="LOCAL-00478" summary="Solve easy but tricky to optimize design a stack that supports popMax() along with usual push() and pop().&#10;&#10;To identify largest value in the stack, we need to use treeMap but in order to delete the largest node in o(1) time, we need a way to directly delete a node. Only DLL supports constant time deletion. So need to model the stack as a DLL.">
      <created>1604420927191</created>
      <option name="number" value="00478" />
      <option name="presentableId" value="LOCAL-00478" />
      <option name="project" value="LOCAL" />
      <updated>1604420927192</updated>
    </task>
    <task id="LOCAL-00479" summary="Solve medium and tricky find the longest substring such that the all characters of the substring can be made equal in &lt;= k operations&#10;&#10;First identify whats the min no of operations required to make all characters same, then use sliding window to find longest such window.&#10;&#10;Learnings -- Longest window vs shortest window -- sliding window implementation is different in both the cases. In former, you keep expanding until window becomes invalid, then you start shrinking until it's valid.&#10;In latter, you expand until you find a valid window, then you start shrinking until it becomes invalid.">
      <created>1604429179220</created>
      <option name="number" value="00479" />
      <option name="presentableId" value="LOCAL-00479" />
      <option name="project" value="LOCAL" />
      <updated>1604429179220</updated>
    </task>
    <task id="LOCAL-00480" summary="Solve medium find the longest subarray that can be transformed to all 1's in &lt;= k operations (0 can be transformed to 1 in one operation)&#10;&#10;Problem reduces to finding the longest subarray with num zeroes &lt;= k, use the standard sliding window paradigm for implementation.">
      <created>1604430244789</created>
      <option name="number" value="00480" />
      <option name="presentableId" value="LOCAL-00480" />
      <option name="project" value="LOCAL" />
      <updated>1604430244789</updated>
    </task>
    <task id="LOCAL-00481" summary="Simplify code by rewriting it to standard sliding window paradigm, keep increasing the window until it becomes invalid, then keep shrinking the window until it becomes valid again.">
      <created>1604433084320</created>
      <option name="number" value="00481" />
      <option name="presentableId" value="LOCAL-00481" />
      <option name="project" value="LOCAL" />
      <updated>1604433084320</updated>
    </task>
    <task id="LOCAL-00482" summary="Solve hard find longest substring containing at most k distinct characters using sliding window.&#10;&#10;Keep track of the distinct chars in the current window, if it exceeds k, continue to shrink the window from the left, until it becomes valid again.">
      <created>1604433223632</created>
      <option name="number" value="00482" />
      <option name="presentableId" value="LOCAL-00482" />
      <option name="project" value="LOCAL" />
      <updated>1604433223632</updated>
    </task>
    <task id="LOCAL-00483" summary="Solve easy but tricky greedy problem, given the initial position of the chips, find the min cost to move them to the same position. &#10;&#10;Min cost can be found if one of the initial state is chosen as the end state, so choose all of the initial position  as the target position and find the total cost to bring remaining chips to it's position.&#10;&#10;This n^2 pattern seems to be pretty common. Can be done in linear time but ....">
      <created>1604600575534</created>
      <option name="number" value="00483" />
      <option name="presentableId" value="LOCAL-00483" />
      <option name="project" value="LOCAL" />
      <updated>1604600575534</updated>
    </task>
    <task id="LOCAL-00484" summary="Solve medium and tricky find nodes that can reach both pacific and atlantic ocean by doing DFS from the oceans and not from the inner nodes.&#10;&#10;Finally I was able to understand why doing DFS in SurroundedRegions from inner nodes resulted in WA -- due to circular dependency.">
      <created>1604601809171</created>
      <option name="number" value="00484" />
      <option name="presentableId" value="LOCAL-00484" />
      <option name="project" value="LOCAL" />
      <updated>1604601809171</updated>
    </task>
    <task id="LOCAL-00485" summary="Add recursive solution similar to knapsack for TwoCityScheduling problem. Every person has two option, go to city A or city B. &#10;&#10;Constraint is that only half of the people can be in any city, couldn't think of recursive solution earlier">
      <created>1604606153392</created>
      <option name="number" value="00485" />
      <option name="presentableId" value="LOCAL-00485" />
      <option name="project" value="LOCAL" />
      <updated>1604606153392</updated>
    </task>
    <task id="LOCAL-00486" summary="Actually solve find the number of distinct islands shapes by storing the relative indices of current island path i.e. when doing a DFS add the relative index of the current node to curPath (relative from starting point of the DFS)&#10;&#10;Using relative index will help in finding similar shapes">
      <created>1604608031859</created>
      <option name="number" value="00486" />
      <option name="presentableId" value="LOCAL-00486" />
      <option name="project" value="LOCAL" />
      <updated>1604608031859</updated>
    </task>
    <task id="LOCAL-00487" summary="Solve medium find whether a graph is a valid tree or not using&#10;&#10;1. DFS + Cycle Detection (Care must be taken to exclude parents as its an undirected graph)&#10;2. Using union find. Thanks to the well explained solution, was able to understand motivation behind path compression with rank in union find operations. Path compression directly connects the descendants to the parent in find_set() operation.&#10;Rank is used to merge smaller set to the larger set during union() operation. This allows smaller updates in the tree during find_set() operation.">
      <created>1604650147190</created>
      <option name="number" value="00487" />
      <option name="presentableId" value="LOCAL-00487" />
      <option name="project" value="LOCAL" />
      <updated>1604650147190</updated>
    </task>
    <task id="LOCAL-00488" summary="Solve medium find whether a graph is a valid tree or not using&#10;&#10;1. DFS + Cycle Detection (Care must be taken to exclude parents as its an undirected graph)&#10;2. Using union find. Thanks to the well explained solution, was able to understand motivation behind path compression with rank in union find operations. Path compression directly connects the descendants to the parent in find_set() operation.&#10;Rank is used to merge smaller set to the larger set during union() operation. This allows smaller updates in the tree during find_set() operation.">
      <created>1604650298692</created>
      <option name="number" value="00488" />
      <option name="presentableId" value="LOCAL-00488" />
      <option name="project" value="LOCAL" />
      <updated>1604650298692</updated>
    </task>
    <task id="LOCAL-00489" summary="Solve medium find number of connected connected in a graph using union find algorithm.&#10;Similar to previously solved NumberOfIslands, can also be done using DFS.">
      <created>1604651747551</created>
      <option name="number" value="00489" />
      <option name="presentableId" value="LOCAL-00489" />
      <option name="project" value="LOCAL" />
      <updated>1604651747551</updated>
    </task>
    <task id="LOCAL-00490" summary="Solve medium clone a graph by DFS + keeping a mapping of source node to cloned node, in order to resolve cycles.">
      <created>1604658411110</created>
      <option name="number" value="00490" />
      <option name="presentableId" value="LOCAL-00490" />
      <option name="project" value="LOCAL" />
      <updated>1604658411111</updated>
    </task>
    <task id="LOCAL-00491" summary="Solve hard find a possible ordering of words given a lexicographically sorted alien dictionary by creating a graph and performing topological sort to detect cycles and ordering among words&#10;&#10;Care must be taken to handle characters that are present but whose ordering cant be determined {&quot;abc&quot;, &quot;abcd&quot;}&#10;&#10;Learnings -- Took me a while to understand that letters in a word are not sorted only the words are sorted. Then there were ambiguity related to handling words that are present but have no specific ordering. Should have thought about that case.">
      <created>1604672473139</created>
      <option name="number" value="00491" />
      <option name="presentableId" value="LOCAL-00491" />
      <option name="project" value="LOCAL" />
      <updated>1604672473139</updated>
    </task>
    <task id="LOCAL-00492" summary="Solve hard and extremely tricky pick max no of cherries in a grid from start to end and back from end to start.&#10;&#10;I started this problem with DP approach of finding the max cherries that can be picked up in the first cycle and then repeat the process in next cycle. However I found out that it gave WA for certain cases because DP in the first cycle acts as a greedy solution and provides local maxima and not the global maxima.&#10;&#10;The trick to solve the problem is to perform recursion, i.e. consider two persons walking from start to end simultaneously and get the max result from 4 states. (right, right), (right, down), (down, right), (down, down)">
      <created>1604754810431</created>
      <option name="number" value="00492" />
      <option name="presentableId" value="LOCAL-00492" />
      <option name="project" value="LOCAL" />
      <updated>1604754810431</updated>
    </task>
    <task id="LOCAL-00493" summary="Solve hard find the max cherries two robots can pick if one starts at top left and another starts at top right. Target state is the last row.&#10;&#10;Similar to CherryPickup. Move both the robots simultaneously. There are 9 possible next states. Take care of the double counting if both of them are at the same cell.">
      <created>1604757878419</created>
      <option name="number" value="00493" />
      <option name="presentableId" value="LOCAL-00493" />
      <option name="project" value="LOCAL" />
      <updated>1604757878419</updated>
    </task>
    <task id="LOCAL-00494" summary="Solve hard and tricky guess the secret word provided a list of candidate words in min no of attempts using brute force + minimax algo&#10;&#10;Learnings -- Finally able to understand minimax algo a bit, need to solve some more problems. Learnt union find a couple of days back and now this. Feeling a bit confident. Lets hope for the best during the interviews :)&#10;&#10;Look in the code for comments around minimax.">
      <created>1604768316284</created>
      <option name="number" value="00494" />
      <option name="presentableId" value="LOCAL-00494" />
      <option name="project" value="LOCAL" />
      <updated>1604768316284</updated>
    </task>
    <task id="LOCAL-00495" summary="Solve easy FlipGame, if two consecutive + is present in the string, it can be replaced by --, need to find all the possible strings that can be generated.">
      <created>1604770406885</created>
      <option name="number" value="00495" />
      <option name="presentableId" value="LOCAL-00495" />
      <option name="project" value="LOCAL" />
      <updated>1604770406885</updated>
    </task>
    <task id="LOCAL-00496" summary="Solve medium flipGame2, game theory problem, need to return whether the current player can win or lose. &#10;&#10;Learnings -- Simulating a game is creating a tree, generate next states possible from current state, those are the children of tree. &#10;Take care of the return value to signal victory/loss of current player.">
      <created>1604772487626</created>
      <option name="number" value="00496" />
      <option name="presentableId" value="LOCAL-00496" />
      <option name="project" value="LOCAL" />
      <updated>1604772487626</updated>
    </task>
    <task id="LOCAL-00497" summary="Solve easy find sum of two numbers &lt; k in an unsorted array by sorting and applying two pointer algorithm.&#10;&#10;Interesting thing to note here was that problem mentioned that find two indices such that i &lt; j. But since sum is commutative, sorting the array might swap the indices but still the resultant sum would be the same">
      <created>1604840679623</created>
      <option name="number" value="00497" />
      <option name="presentableId" value="LOCAL-00497" />
      <option name="project" value="LOCAL" />
      <updated>1604840679623</updated>
    </task>
    <task id="LOCAL-00498" summary="Update solution in Subsets to accommodate the logical choice present for each index in the result. Each index can either be present or be absent in the result. So just simulate the choices for all indices.">
      <created>1604842346903</created>
      <option name="number" value="00498" />
      <option name="presentableId" value="LOCAL-00498" />
      <option name="project" value="LOCAL" />
      <updated>1604842346903</updated>
    </task>
    <task id="LOCAL-00499" summary="Add comment regarding another way of generating all the subsets by leveraging binary numbers">
      <created>1604843955492</created>
      <option name="number" value="00499" />
      <option name="presentableId" value="LOCAL-00499" />
      <option name="project" value="LOCAL" />
      <updated>1604843955492</updated>
    </task>
    <task id="LOCAL-00500" summary="Add another way of solving Subsets with duplicates, in which we add a duplicate number to the result only if the previous duplicate is also added, otherwise we just skip this duplicate number.">
      <created>1604844924069</created>
      <option name="number" value="00500" />
      <option name="presentableId" value="LOCAL-00500" />
      <option name="project" value="LOCAL" />
      <updated>1604844924069</updated>
    </task>
    <task id="LOCAL-00501" summary="Add clarification in output of the problem, need to return the no of edges in the longest univalue path, not the no of elements present">
      <created>1604848273885</created>
      <option name="number" value="00501" />
      <option name="presentableId" value="LOCAL-00501" />
      <option name="project" value="LOCAL" />
      <updated>1604848273885</updated>
    </task>
    <task id="LOCAL-00502" summary="Solve medium and tricky problem, find no of moves required to make all the nodes in the tree with 1 coin.&#10;&#10;Try to think about what info is required from the children, and update result and return value accordingly.&#10;Here we need the surplus/deficit from left/right subtree. Once we know that, we can calculate the total surplus/deficit of current subtree.&#10;Moves required at each node is the absolute value of surplus/deficit at that node e.g. if a node has surplus 3, it needs 3 moves to transfer the surplus because that node can have value = 1 in the end state.">
      <created>1604848532167</created>
      <option name="number" value="00502" />
      <option name="presentableId" value="LOCAL-00502" />
      <option name="project" value="LOCAL" />
      <updated>1604848532167</updated>
    </task>
    <task id="LOCAL-00503" summary="Add approach in find all nodes present at k distance in binary tree">
      <created>1604849239156</created>
      <option name="number" value="00503" />
      <option name="presentableId" value="LOCAL-00503" />
      <option name="project" value="LOCAL" />
      <updated>1604849239156</updated>
    </task>
    <task id="LOCAL-00504" summary="Add gotcha around resetting prefix sum of histogram if the current column value is 0, because we are only interested in longest histogram height of 1's ending at current col">
      <created>1604850172740</created>
      <option name="number" value="00504" />
      <option name="presentableId" value="LOCAL-00504" />
      <option name="project" value="LOCAL" />
      <updated>1604850172740</updated>
    </task>
    <task id="LOCAL-00505" summary="Solve easy find moving average of last k elements from stream using fixed size deque and circular array.&#10;&#10;Learnings -- Circular array can be used to solve question of fixed window size. Circular array can be implemented by fixed size array by keeping two pointers, head/tail and using modular arithmetic while incrementing head/tail">
      <created>1604867094441</created>
      <option name="number" value="00505" />
      <option name="presentableId" value="LOCAL-00505" />
      <option name="project" value="LOCAL" />
      <updated>1604867094441</updated>
    </task>
    <task id="LOCAL-00506" summary="Solve medium find max difference between a node and its ancestor in binary tree by keeping track of min and max val found so far during recursion.&#10;&#10;Little bit tricky but was able to solve it quickly.">
      <created>1604935078578</created>
      <option name="number" value="00506" />
      <option name="presentableId" value="LOCAL-00506" />
      <option name="project" value="LOCAL" />
      <updated>1604935078578</updated>
    </task>
    <task id="LOCAL-00507" summary="Solve hard and tricky find min no of cameras to place to cover a binary tree. This is similar to vertex cover but is very tricky.&#10;&#10;Trick is to consider it as a greedy problem rather than recursion problem, think about not placing a camera at the edge but at the center. So lead node should not have a camera, and instead it's parent should have a camera.&#10;&#10;Sequence of covering would be covered (null pointers of leaf) -&gt; uncovered -&gt; place camera -&gt; covered -&gt; uncovered -&gt; place camera ..">
      <created>1604940499610</created>
      <option name="number" value="00507" />
      <option name="presentableId" value="LOCAL-00507" />
      <option name="project" value="LOCAL" />
      <updated>1604940499610</updated>
    </task>
    <task id="LOCAL-00508" summary="Solve medium and tricky game theory problem. &#10;&#10;Multiple gotchas in game theory:&#10;1. Filter out invalid/unreachable inputs prior to starting recursion.&#10;&#10;2. When there is state to memoize, memoize the input state at the current recursion, not the choices performed after the input state.&#10;&#10;3. When a player wins after making a choice, that's not the end of the game. Other player will still continue performing the backtracking. So reset all the choices made before returning true to the next player.">
      <created>1604952696502</created>
      <option name="number" value="00508" />
      <option name="presentableId" value="LOCAL-00508" />
      <option name="project" value="LOCAL" />
      <updated>1604952696502</updated>
    </task>
    <task id="LOCAL-00509" summary="Solve medium and tricky game theory problem predictTheWinner, need to find the max score of the first player if each player picks either from the left or from the right.&#10;&#10;Since we need to maximise the score, we need to use MaxiMin algorithm. There are two ways of implementing maximin algo. Either use flag to denote who is playing or directly skip to the player1 state without considering player2 state at all.&#10;&#10;Former one needs to carefully handle return value for both the players assuming that we are interested only in score of player1">
      <created>1605022894332</created>
      <option name="number" value="00509" />
      <option name="presentableId" value="LOCAL-00509" />
      <option name="project" value="LOCAL" />
      <updated>1605022894332</updated>
    </task>
    <option name="localTasksCounter" value="510" />
    <servers />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="1">
          <value>
            <State>
              <option name="FILTERS">
                <map>
                  <entry key="roots">
                    <value>
                      <list>
                        <option value="$PROJECT_DIR$" />
                      </list>
                    </value>
                  </entry>
                </map>
              </option>
            </State>
          </value>
        </entry>
        <entry key="2">
          <value>
            <State>
              <option name="FILTERS">
                <map>
                  <entry key="roots">
                    <value>
                      <list>
                        <option value="$PROJECT_DIR$" />
                      </list>
                    </value>
                  </entry>
                  <entry key="text">
                    <value>
                      <list>
                        <option value="hard and tricky" />
                      </list>
                    </value>
                  </entry>
                  <entry key="user">
                    <value>
                      <list>
                        <option value="snehasishiiita" />
                      </list>
                    </value>
                  </entry>
                </map>
              </option>
            </State>
          </value>
        </entry>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_WIDTH">
                <map>
                  <entry key="2" value="82" />
                </map>
              </option>
            </State>
          </value>
        </entry>
      </map>
    </option>
    <option name="oldMeFiltersMigrated" value="true" />
  </component>
  <component name="VcsManagerConfiguration">
    <option name="CHECK_CODE_CLEANUP_BEFORE_PROJECT_COMMIT" value="true" />
    <MESSAGE value="Solve medium and tricky find nodes that can reach both pacific and atlantic ocean by doing DFS from the oceans and not from the inner nodes.&#10;&#10;Finally I was able to understand why doing DFS in SurroundedRegions from inner nodes resulted in WA -- due to circular dependency." />
    <MESSAGE value="Add recursive solution similar to knapsack for TwoCityScheduling problem. Every person has two option, go to city A or city B. &#10;&#10;Constraint is that only half of the people can be in any city, couldn't think of recursive solution earlier" />
    <MESSAGE value="Actually solve find the number of distinct islands shapes by storing the relative indices of current island path i.e. when doing a DFS add the relative index of the current node to curPath (relative from starting point of the DFS)&#10;&#10;Using relative index will help in finding similar shapes" />
    <MESSAGE value="Solve medium find whether a graph is a valid tree or not using&#10;&#10;1. DFS + Cycle Detection (Care must be taken to exclude parents as its an undirected graph)&#10;2. Using union find. Thanks to the well explained solution, was able to understand motivation behind path compression with rank in union find operations. Path compression directly connects the descendants to the parent in find_set() operation.&#10;Rank is used to merge smaller set to the larger set during union() operation. This allows smaller updates in the tree during find_set() operation." />
    <MESSAGE value="Solve medium find number of connected connected in a graph using union find algorithm.&#10;Similar to previously solved NumberOfIslands, can also be done using DFS." />
    <MESSAGE value="Solve medium clone a graph by DFS + keeping a mapping of source node to cloned node, in order to resolve cycles." />
    <MESSAGE value="Solve hard find a possible ordering of words given a lexicographically sorted alien dictionary by creating a graph and performing topological sort to detect cycles and ordering among words&#10;&#10;Care must be taken to handle characters that are present but whose ordering cant be determined {&quot;abc&quot;, &quot;abcd&quot;}&#10;&#10;Learnings -- Took me a while to understand that letters in a word are not sorted only the words are sorted. Then there were ambiguity related to handling words that are present but have no specific ordering. Should have thought about that case." />
    <MESSAGE value="Solve hard and extremely tricky pick max no of cherries in a grid from start to end and back from end to start.&#10;&#10;I started this problem with DP approach of finding the max cherries that can be picked up in the first cycle and then repeat the process in next cycle. However I found out that it gave WA for certain cases because DP in the first cycle acts as a greedy solution and provides local maxima and not the global maxima.&#10;&#10;The trick to solve the problem is to perform recursion, i.e. consider two persons walking from start to end simultaneously and get the max result from 4 states. (right, right), (right, down), (down, right), (down, down)" />
    <MESSAGE value="Solve hard find the max cherries two robots can pick if one starts at top left and another starts at top right. Target state is the last row.&#10;&#10;Similar to CherryPickup. Move both the robots simultaneously. There are 9 possible next states. Take care of the double counting if both of them are at the same cell." />
    <MESSAGE value="Solve hard and tricky guess the secret word provided a list of candidate words in min no of attempts using brute force + minimax algo&#10;&#10;Learnings -- Finally able to understand minimax algo a bit, need to solve some more problems. Learnt union find a couple of days back and now this. Feeling a bit confident. Lets hope for the best during the interviews :)&#10;&#10;Look in the code for comments around minimax." />
    <MESSAGE value="Solve easy FlipGame, if two consecutive + is present in the string, it can be replaced by --, need to find all the possible strings that can be generated." />
    <MESSAGE value="Solve medium flipGame2, game theory problem, need to return whether the current player can win or lose. &#10;&#10;Learnings -- Simulating a game is creating a tree, generate next states possible from current state, those are the children of tree. &#10;Take care of the return value to signal victory/loss of current player." />
    <MESSAGE value="Solve easy find sum of two numbers &lt; k in an unsorted array by sorting and applying two pointer algorithm.&#10;&#10;Interesting thing to note here was that problem mentioned that find two indices such that i &lt; j. But since sum is commutative, sorting the array might swap the indices but still the resultant sum would be the same" />
    <MESSAGE value="Update solution in Subsets to accommodate the logical choice present for each index in the result. Each index can either be present or be absent in the result. So just simulate the choices for all indices." />
    <MESSAGE value="Add comment regarding another way of generating all the subsets by leveraging binary numbers" />
    <MESSAGE value="Add another way of solving Subsets with duplicates, in which we add a duplicate number to the result only if the previous duplicate is also added, otherwise we just skip this duplicate number." />
    <MESSAGE value="Add clarification in output of the problem, need to return the no of edges in the longest univalue path, not the no of elements present" />
    <MESSAGE value="Solve medium and tricky problem, find no of moves required to make all the nodes in the tree with 1 coin.&#10;&#10;Try to think about what info is required from the children, and update result and return value accordingly.&#10;Here we need the surplus/deficit from left/right subtree. Once we know that, we can calculate the total surplus/deficit of current subtree.&#10;Moves required at each node is the absolute value of surplus/deficit at that node e.g. if a node has surplus 3, it needs 3 moves to transfer the surplus because that node can have value = 1 in the end state." />
    <MESSAGE value="Add approach in find all nodes present at k distance in binary tree" />
    <MESSAGE value="Add gotcha around resetting prefix sum of histogram if the current column value is 0, because we are only interested in longest histogram height of 1's ending at current col" />
    <MESSAGE value="Solve easy find moving average of last k elements from stream using fixed size deque and circular array.&#10;&#10;Learnings -- Circular array can be used to solve question of fixed window size. Circular array can be implemented by fixed size array by keeping two pointers, head/tail and using modular arithmetic while incrementing head/tail" />
    <MESSAGE value="Solve medium find max difference between a node and its ancestor in binary tree by keeping track of min and max val found so far during recursion.&#10;&#10;Little bit tricky but was able to solve it quickly." />
    <MESSAGE value="Solve hard and tricky find min no of cameras to place to cover a binary tree. This is similar to vertex cover but is very tricky.&#10;&#10;Trick is to consider it as a greedy problem rather than recursion problem, think about not placing a camera at the edge but at the center. So lead node should not have a camera, and instead it's parent should have a camera.&#10;&#10;Sequence of covering would be covered (null pointers of leaf) -&gt; uncovered -&gt; place camera -&gt; covered -&gt; uncovered -&gt; place camera .." />
    <MESSAGE value="Solve medium and tricky game theory problem. &#10;&#10;Multiple gotchas in game theory:&#10;1. Filter out invalid/unreachable inputs prior to starting recursion.&#10;&#10;2. When there is state to memoize, memoize the input state at the current recursion, not the choices performed after the input state.&#10;&#10;3. When a player wins after making a choice, that's not the end of the game. Other player will still continue performing the backtracking. So reset all the choices made before returning true to the next player." />
    <MESSAGE value="Solve medium and tricky game theory problem predictTheWinner, need to find the max score of the first player if each player picks either from the left or from the right.&#10;&#10;Since we need to maximise the score, we need to use MaxiMin algorithm. There are two ways of implementing maximin algo. Either use flag to denote who is playing or directly skip to the player1 state without considering player2 state at all.&#10;&#10;Former one needs to carefully handle return value for both the players assuming that we are interested only in score of player1" />
    <option name="LAST_COMMIT_MESSAGE" value="Solve medium and tricky game theory problem predictTheWinner, need to find the max score of the first player if each player picks either from the left or from the right.&#10;&#10;Since we need to maximise the score, we need to use MaxiMin algorithm. There are two ways of implementing maximin algo. Either use flag to denote who is playing or directly skip to the player1 state without considering player2 state at all.&#10;&#10;Former one needs to carefully handle return value for both the players assuming that we are interested only in score of player1" />
    <option name="OPTIMIZE_IMPORTS_BEFORE_PROJECT_COMMIT" value="true" />
    <option name="REFORMAT_BEFORE_PROJECT_COMMIT" value="true" />
    <option name="REARRANGE_BEFORE_PROJECT_COMMIT" value="true" />
  </component>
  <component name="WindowStateProjectService">
    <state x="726" y="229" key="#Auto_Import" timestamp="1599427305776">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="726" y="229" key="#Auto_Import/0.0.1920.1050@0.0.1920.1050" timestamp="1599427305776" />
    <state x="586" y="203" key="#Inspections" timestamp="1602866625843">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="586" y="203" key="#Inspections/0.0.1920.1050@0.0.1920.1050" timestamp="1602866625843" />
    <state x="727" y="349" key="#Notifications" timestamp="1598814073398">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="727" y="349" key="#Notifications/0.0.1920.1050@0.0.1920.1050" timestamp="1598814073398" />
    <state x="552" y="166" key="#Plugins" timestamp="1605009261465">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="552" y="166" key="#Plugins/0.0.1920.1050@0.0.1920.1050" timestamp="1605009261465" />
    <state x="765" y="231" key="#com.intellij.ide.util.MemberChooser" timestamp="1604417536568">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="765" y="231" key="#com.intellij.ide.util.MemberChooser/0.0.1920.1050@0.0.1920.1050" timestamp="1604417536568" />
    <state x="703" y="304" key="#com.intellij.ide.util.PackageChooserDialog" timestamp="1597609089094">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="703" y="304" key="#com.intellij.ide.util.PackageChooserDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1597609089094" />
    <state x="640" y="254" key="#com.intellij.openapi.updateSettings.impl.PluginUpdateInfoDialog" timestamp="1600328299277">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="640" y="254" key="#com.intellij.openapi.updateSettings.impl.PluginUpdateInfoDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1600328299277" />
    <state x="820" y="449" key="#com.intellij.refactoring.move.MoveHandler.SelectRefactoringDialog" timestamp="1597609083441">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="820" y="449" key="#com.intellij.refactoring.move.MoveHandler.SelectRefactoringDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1597609083441" />
    <state x="756" y="384" width="433" height="288" key="#com.intellij.refactoring.move.moveClassesOrPackages.MoveClassesOrPackagesDialog.classes" timestamp="1604606328118">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="756" y="384" width="433" height="288" key="#com.intellij.refactoring.move.moveClassesOrPackages.MoveClassesOrPackagesDialog.classes/0.0.1920.1050@0.0.1920.1050" timestamp="1604606328118" />
    <state x="743" y="369" key="#com.intellij.refactoring.move.moveInner.MoveInnerDialog" timestamp="1597609092731">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="743" y="369" key="#com.intellij.refactoring.move.moveInner.MoveInnerDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1597609092731" />
    <state x="504" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog" timestamp="1604840703273">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="504" y="0" key="#com.intellij.refactoring.rename.AutomaticRenamingDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1604840703273" />
    <state x="690" y="272" key="#com.intellij.refactoring.safeDelete.UnsafeUsagesDialog" timestamp="1601403451266">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="690" y="272" key="#com.intellij.refactoring.safeDelete.UnsafeUsagesDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1601403451266" />
    <state x="1378" y="422" key="#xdebugger.evaluate" timestamp="1603206721809">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="1378" y="422" key="#xdebugger.evaluate/0.0.1920.1050@0.0.1920.1050" timestamp="1603206721809" />
    <state x="435" y="72" width="1374" height="978" key="CommitChangelistDialog2" timestamp="1605022893731">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="435" y="72" width="1374" height="978" key="CommitChangelistDialog2/0.0.1920.1050@0.0.1920.1050" timestamp="1605022893731" />
    <state width="412" height="466" key="DebuggerActiveHint" timestamp="1599062046773">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="412" height="466" key="DebuggerActiveHint/0.0.1920.1050@0.0.1920.1050" timestamp="1599062046773" />
    <state width="456" height="442" key="Diff.GoToChangePopup" timestamp="1603722673482">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="456" height="442" key="Diff.GoToChangePopup/0.0.1920.1050@0.0.1920.1050" timestamp="1603722673482" />
    <state x="368" y="174" width="1536" height="867" maximized="true" key="DiffContextDialog" timestamp="1604952963975">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="368" y="174" width="1536" height="867" maximized="true" key="DiffContextDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1604952963975" />
    <state x="969" y="325" key="FileChooserDialogImpl" timestamp="1604517634549">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="969" y="325" key="FileChooserDialogImpl/0.0.1920.1050@0.0.1920.1050" timestamp="1604517634549" />
    <state x="550" y="425" key="Git.Rebase.Log.Action.NewCommitMessage.Dialog" timestamp="1596567099935">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="550" y="425" key="Git.Rebase.Log.Action.NewCommitMessage.Dialog/0.0.1920.1050@0.0.1920.1050" timestamp="1596567099935" />
    <state width="1877" height="352" key="GridCell.Tab.0.bottom" timestamp="1605014130330">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="352" key="GridCell.Tab.0.bottom/0.0.1920.1050@0.0.1920.1050" timestamp="1605014130330" />
    <state width="1877" height="352" key="GridCell.Tab.0.center" timestamp="1605014130330">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="352" key="GridCell.Tab.0.center/0.0.1920.1050@0.0.1920.1050" timestamp="1605014130330" />
    <state width="1877" height="352" key="GridCell.Tab.0.left" timestamp="1605014130330">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="352" key="GridCell.Tab.0.left/0.0.1920.1050@0.0.1920.1050" timestamp="1605014130330" />
    <state width="1877" height="352" key="GridCell.Tab.0.right" timestamp="1605014130330">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="352" key="GridCell.Tab.0.right/0.0.1920.1050@0.0.1920.1050" timestamp="1605014130330" />
    <state width="1877" height="352" key="GridCell.Tab.1.bottom" timestamp="1605014130332">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="352" key="GridCell.Tab.1.bottom/0.0.1920.1050@0.0.1920.1050" timestamp="1605014130332" />
    <state width="1877" height="352" key="GridCell.Tab.1.center" timestamp="1605014130332">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="352" key="GridCell.Tab.1.center/0.0.1920.1050@0.0.1920.1050" timestamp="1605014130332" />
    <state width="1877" height="352" key="GridCell.Tab.1.left" timestamp="1605014130331">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="352" key="GridCell.Tab.1.left/0.0.1920.1050@0.0.1920.1050" timestamp="1605014130331" />
    <state width="1877" height="352" key="GridCell.Tab.1.right" timestamp="1605014130332">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="352" key="GridCell.Tab.1.right/0.0.1920.1050@0.0.1920.1050" timestamp="1605014130332" />
    <state width="1877" height="285" key="GridCell.Tab.2.bottom" timestamp="1599757745387">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="285" key="GridCell.Tab.2.bottom/0.0.1920.1050@0.0.1920.1050" timestamp="1599757745387" />
    <state width="1877" height="285" key="GridCell.Tab.2.center" timestamp="1599757745387">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="285" key="GridCell.Tab.2.center/0.0.1920.1050@0.0.1920.1050" timestamp="1599757745387" />
    <state width="1877" height="285" key="GridCell.Tab.2.left" timestamp="1599757745387">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="285" key="GridCell.Tab.2.left/0.0.1920.1050@0.0.1920.1050" timestamp="1599757745387" />
    <state width="1877" height="285" key="GridCell.Tab.2.right" timestamp="1599757745387">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="1877" height="285" key="GridCell.Tab.2.right/0.0.1920.1050@0.0.1920.1050" timestamp="1599757745387" />
    <state x="695" y="245" key="RollbackChangesDialog" timestamp="1598184917635">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="695" y="245" key="RollbackChangesDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1598184917635" />
    <state x="668" y="259" key="SettingsEditor" timestamp="1605009275315">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="668" y="259" key="SettingsEditor/0.0.1920.1050@0.0.1920.1050" timestamp="1605009275315" />
    <state x="681" y="266" width="570" height="524" key="StructurePopup" timestamp="1604434978061">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="681" y="266" width="570" height="524" key="StructurePopup/0.0.1920.1050@0.0.1920.1050" timestamp="1604434978061" />
    <state width="498" height="446" key="SwitcherDM" timestamp="1604865768156">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="498" height="446" key="SwitcherDM/0.0.1920.1050@0.0.1920.1050" timestamp="1604865768156" />
    <state x="669" y="222" key="VCS.ChangeListViewerDialog" timestamp="1604602218235">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="669" y="222" key="VCS.ChangeListViewerDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1604602218235" />
    <state x="807" y="439" key="VCS.ChangelistChooser" timestamp="1598799850245">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="807" y="439" key="VCS.ChangelistChooser/0.0.1920.1050@0.0.1920.1050" timestamp="1598799850245" />
    <state x="870" y="99" key="Vcs.Push.Dialog.v2" timestamp="1605022895583">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="870" y="99" key="Vcs.Push.Dialog.v2/0.0.1920.1050@0.0.1920.1050" timestamp="1605022895583" />
    <state x="775" y="303" key="chooseDestDirectoryDialog" timestamp="1597609092682">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="775" y="303" key="chooseDestDirectoryDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1597609092682" />
    <state x="562" y="135" key="com.intellij.openapi.editor.actions.MultiplePasteAction$ClipboardContentChooser" timestamp="1603744207245">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="562" y="135" key="com.intellij.openapi.editor.actions.MultiplePasteAction$ClipboardContentChooser/0.0.1920.1050@0.0.1920.1050" timestamp="1603744207245" />
    <state x="769" y="439" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2" timestamp="1604256234093">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="769" y="439" key="com.intellij.openapi.vcs.update.UpdateOrStatusOptionsDialogupdate-v2/0.0.1920.1050@0.0.1920.1050" timestamp="1604256234093" />
    <state x="489" y="261" width="941" height="629" key="com.intellij.xdebugger.impl.breakpoints.ui.BreakpointsDialogFactory$2" timestamp="1603983886792">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="489" y="261" width="941" height="629" key="com.intellij.xdebugger.impl.breakpoints.ui.BreakpointsDialogFactory$2/0.0.1920.1050@0.0.1920.1050" timestamp="1603983886792" />
    <state x="690" y="275" key="extract.method.dialog" timestamp="1604653793268">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="690" y="275" key="extract.method.dialog/0.0.1920.1050@0.0.1920.1050" timestamp="1604653793268" />
    <state x="667" y="258" width="1045" height="624" key="find.popup" timestamp="1604517641710">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="667" y="258" width="1045" height="624" key="find.popup/0.0.1920.1050@0.0.1920.1050" timestamp="1604517641710" />
    <state width="750" height="250" key="javadoc.popup.new" timestamp="1604767283623">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state width="750" height="250" key="javadoc.popup.new/0.0.1920.1050@0.0.1920.1050" timestamp="1604767283623" />
    <state x="666" y="282" key="refactoring.ChangeSignatureDialog" timestamp="1605023640909">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="666" y="282" key="refactoring.ChangeSignatureDialog/0.0.1920.1050@0.0.1920.1050" timestamp="1605023640909" />
    <state x="616" y="243" width="672" height="677" key="run.anything.popup" timestamp="1604866424004">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="616" y="243" width="672" height="677" key="run.anything.popup/0.0.1920.1050@0.0.1920.1050" timestamp="1604866424004" />
    <state x="623" y="227" width="766" height="650" key="search.everywhere.popup" timestamp="1605023652048">
      <screen x="0" y="0" width="1920" height="1050" />
    </state>
    <state x="623" y="227" width="766" height="650" key="search.everywhere.popup/0.0.1920.1050@0.0.1920.1050" timestamp="1605023652048" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/main/java/DistinctSubsequences.java</url>
          <line>78</line>
          <option name="timeStamp" value="1" />
        </line-breakpoint>
      </breakpoints>
      <default-breakpoints>
        <breakpoint enabled="true" type="java-exception">
          <condition expression="this instanceof StringIndexOutOfBoundsException" language="JAVA" />
          <properties>
            <catch-class-filters>
              <class-filter pattern="java.lang.ArrayIndexOutOfBoundsException" />
            </catch-class-filters>
          </properties>
        </breakpoint>
      </default-breakpoints>
    </breakpoint-manager>
    <watches-manager>
      <configuration name="JUnit">
        <watch expression="grid" />
        <watch expression="uniqueString.entrySet().toArray()[0]" />
      </configuration>
    </watches-manager>
  </component>
  <component name="XSLT-Support.FileAssociations.UIState">
    <expand />
    <select />
  </component>
</project>