Given an array A and a list of [X,Y] indexes, a special sum is calculated by sum of all subarrays [Ax, Ay] for x,y in the list.
You need to maximise the sum by rearranging the array. Find the maximum value which can be obtained.
Array:
9 1 6 1

List of [X,Y]:
1 1
1 2
1 3
https://www.geeksforgeeks.org/maximum-sum-after-rearranging-the-array-for-k-queries/

Return 40 Reverse -> 9 6 1 1, 9*3 + 6*2 + 1*1 = 40 place 9 on 1, 6 on 2 and 3 on 1
Public int maxProfit(int[] arr, int[][] ranges) {
	Int n = arr.length;
	Int[] frequencyOfIndices = new int[n + 1];
	For (int[] range : ranges) {
		frequencyOfIndices[range[0]] ++;
		frequencyOfIndices[range[1] + 1] --;
	}
	For (int i = 1; i <= n; i++) {
		frequencyOfIndices[i] += frequencyOfIndices[i - 1]; //cumulative sum
	}
	//reverse sort the arr
	Arrays.sort(arr, Comparator.reverseOrder());
	//reverse sort the frequencyOfIndices

//0 0 0 0 1 1 1 2 2 2 3 3 3 1 1 0 0
	Arrays.sort(frequencyOfIndices, Comparator.reverseOrder());
	Int profit = 0;
For (int i = 0; i <= n; i++) {
		Profit += frequencyOfIndices[i] * arr[i];
	}
	Return profit;
}

A Perfect Hill is a sequence of integers. It has some interesting properties.
路  Perfect Hill is of odd length i.e. L = 2*n + 1.
路  The first (n+1) integers of the Perfect Hill sequence make a strictly increasing sequence.
路  The last (n+1) integers of the Perfect Hill sequence make a strictly decreasing sequence.
路  No two adjacent integers are same in a Perfect Hill sequence.
For example 1, 2, 3, 4, 5, 4, 3, 2, 0 is a Perfect Hill sequence of length 9. But 1, 2, 3, 4, 5, 4, 3, 2, 2 is not a valid Perfect Hill sequence.
In this problem, you will be given a sequence of integers. You have to find out the length of the longest Perfect Hill sequence which is a subsequence of the given sequence.

Example: Consider the sequence 1 2 3 2 1 2 3 4 3 2 1 5 4 1 2 3 2 1 0.

Here the longest Perfect Hill sequence is: 1 2 3 4 5 4 3 1 0. So, the output will be 9.

https://www.geeksforgeeks.org/longest-bitonic-subsequence-dp-15/

Public int longestHill(int[] arr) {
	int [] left = longestIncreasingSubsequence(arr);
	Int[] right = longestIncreasingSubsequence(Arrays.reverse(arr));
	Right = Arrays.reverse(right);
Int longestHillLength = 0;
	For (int i = 0; i < n; i++) {
		Int curLength = (Math.min(left[i], right[i]) * 2) - 1;
		longestHillLength = Math.max(longestHillLength, curLength);
}
	Return longestHillLength;
}

Private int[] longestIncreasingSubsequence(int[] arr) {
	Int n = arr.length;
	Int[] lis = new int[n];
	Arrays.fill(lis, 1);
	For (int i = 1; i < n; i++) {
		For (int j = 0; j < i; j++) {
			If (arr[j] < arr[i]) {
				Lis[i] = Math.max(lis[i], lis[j] + 1);
			}
		}
}
Return lis;
}
________________________________________________________________________________________________________________________
Design Round
Create a platform that supports generating business metrics like click through rate, impressions for images
and can support queries like how many clicks for this image where location is bangalore and gender is male

I was able to generate data ingestion platform but struggled a lot in data aggregation as I was trying to do it
in-memory or in key/value store itself. Later after talking to shashwat realized that it's a data warehouse
operation and would require a different data store itself in which you need to push data to spark that can aggregate data.

https://jamboard.google.com/d/128d7zYIaXgMe1wmMqdOkwmp_mq1oIifISlmCl0iWB64/viewer

Feedback of this round was not positive but due to strong positive feedback in DSA and probably machine coding round,
I was given a second chance to ace another design round. They were keen on hiring me as a SDE2 but given my current CTC and YOE,
probably they thought SDE3 would be an appropriate level.

_______________________________________________________________________________________________________________________
Design Round - Another chance
Design Cricinfo platform to support realtime events like score and commentary to end users

Explained using websockets, where we would store a list of webclients that are interested in a match_id
Then use pub-sub mechanism (kafka) to push events of a specific match to all the interested websockets
Also used an in-memory store e.g. redis or aerospike to maintain a sorted dataset for commentary to give info for fresh user

https://jamboard.google.com/d/11u-m1hpIsl3O2UL06f9NYkpcoGv82zvDDBDxsRoCAgw/viewer
https://www.youtube.com/watch?v=exSwQtMxGd4